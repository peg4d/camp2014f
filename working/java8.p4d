// PEG4d Java8 Grammar
// ===============

export
	= Statement
	/ Expression
	/ Constant

File
	= _ { (@PackageDeclaration _ )? (@ImportDeclaration _ )* (@TypeDeclaration _ )* #Source } EOT


Chunk
	= TopLevel
	/ Statement
	/ Expression
	/ Type
_
	= (S / BLOCKCOMMENT / LINECOMMENT )*

S
	= [ \n\r\t\u000B\u000C]

BLOCKCOMMENT
	= '/*' (!'*/' .)* '*/'

LINECOMMENT
	= '//' (!'\n' .)*


EOL
	= ('\r'? '\n' / !.)

DIGIT
	= [0-9]

W
	= [a-zA-Z0-9_$]

HEX
	= [a-fA-F0-9]

HEX4
	= HEX HEX HEX HEX

Name
	= { NAME #Name } _

NAME
	= !DIGIT !(KEYWORD !W) W+

KEYWORD
	= 'abstract' / 'assert' / 'boolean' / 'break' / 'byte' / 'case'
	/ 'catch' / 'char' / 'class' / 'const' / 'continue' / 'default'
	/ 'double' / 'do' / 'else' / 'enum' / 'extends' / 'false'
	/ 'final' / 'finally' / 'float' / 'for' / 'goto' / 'if' / 'implements'
	/ 'import' / 'instanceof' / 'interface' / 'int' / 'long' / 'native'
	/ 'new' / 'null' / 'package' / 'private' / 'protected' / 'public'
	/ 'return' / 'short' / 'static' / 'strictfp' / 'super' / 'switch'
	/ 'synchronized' / 'this' / 'throws' / 'throw' / 'transient'
	/ 'true' / 'try' / 'void' / 'volatile' / 'while'

"++"   = '++'
"--"   = '--'
"&"    = '&' ![&=]
"*"    = '*' !'='
"+"    = '+' ![+=]
"-"    = '-' !('-' / [=>])
"~"    = '~'
"!"    = '!' !'='

"{"    = '{'
"["    = '['
"]"    = ']'
","    = ','
"..."  = '...'
":"    = ':' ![>]
"/"    = '/' !'='
"%"    = '%' ![=>]
"<<"   = '<<' !'='
">>"   = '>>' ![=>]
">>>"  = '>>>' !'='
"<="   = '<='
">="   = '>='
"<"    = '<' ![=]
">"    = '>' ![=]
"=="   = '=='
"!="   = '!='
"^"    = '^' ![=]
"|"    = '|' ![|=]
"&&"   = '&&'
"||"   = '||'
"?"    = '?'
";"    = ';'
"}"    = '}'

"*="   = '*='
"/="   = '/='
"%="   = '%='
"+="   = '+='
"-="   = '-='
"<<="  = '<<='
">>="  = '>>='
">>>=" = '>>>='
"&="   = '&='
"^="   = '^='
"|="   = '|='
"="    = '=' !'='
"."    = '.'

"("    = '('
")"    = ')'

"@"    = '@'
"->"   = '->'

// reserved keyword
"abstract"     = 'abstract'     !W
"assert"       = 'assert'       !W
"boolean"      = 'boolean'      !W
"break"        = 'break'        !W
"byte"         = 'byte'         !W
"case"         = 'case'         !W
"catch"        = 'catch'        !W
"char"         = 'char'         !W
"class"        = 'class'        !W
"const"        = 'const'        !W
"continue"     = 'continue'     !W
"default"      = 'default'      !W
"do"           = 'do'           !W
"double"       = 'double'       !W
"else"         = 'else'         !W
"enum"         = 'enum'         !W
"extends"      = 'extends'      !W
"false"        = 'false'        !W
"final"        = 'final'        !W
"finally"      = 'finally'      !W
"float"        = 'float'        !W
"for"          = 'for'          !W
"goto"         = 'goto'         !W
"if"           = 'if'           !W
"implements"   = 'implements'   !W
"import"       = 'import'       !W
"instanceof"   = 'instanceof'   !W
"int"          = 'int'          !W
"interface"    = 'interface'    !W
"long"         = 'long'         !W
"native"       = 'native'       !W
"new"          = 'new'          !W
"null"         = 'null'         !W
"package"      = 'package'      !W
"private"      = 'private'      !W
"protected"    = 'protected'    !W
"public"       = 'public'       !W
"return"       = 'return'       !W
"short"        = 'short'        !W
"static"       = 'static'       !W
"strictfp"     = 'strictfp'     !W
"super"        = 'super'        !W
"switch"       = 'switch'       !W
"synchronized" = 'synchronized' !W
"this"         = 'this'         !W
"throw"        = 'throw'        !W
"throws"       = 'throws'       !W
"transient"    = 'transient'    !W
"true"         = 'true'         !W
"try"          = 'try'          !W
"void"         = 'void'         !W
"volatile"     = 'volatile'     !W
"while"        = 'while'        !W


EOT = !.

TopLevel
	= PackageDeclaration
	/ ImportDeclaration
	/ TypeDeclaration


// package definition
PackageDeclaration
	= { (@PackageModifier)* _ "package" _ @TypeName ";" #PackageDeclaration } _

PackageModifier
	= Annotation

// import definition
ImportDeclaration
	= TypeImportOnDemandDeclaration
	/ SingleTypeImportDeclaration
	/ StaticImportOnDemandDeclaration
	/ SingleStaticImportDeclaration

SingleTypeImportDeclaration
	= "import" _ { @TypeName #SingleTypeImportDeclaration } _ ";" _

TypeImportOnDemandDeclaration
	= "import" _ { @TypeName  _ "." _ "*" #TypeImportOnDemandDeclaration } _ ";" _

SingleStaticImportDeclaration
	= "import" _ "static" _ { @TypeName #SingleStaticImportDeclaration } _ ";" _

StaticImportOnDemandDeclaration
	= "import" _ "static" _ { @TypeName #StaticImportOnDemandDeclaration } _ "." _ "*" _ ";" _

// type definition
TypeDeclaration
	= ClassDeclaration
	/ InterfaceDeclaration
	/ { ";" #Empty } _

// annotation definition
Annotation
	= NormalAnnotation
	/ SingleElementAnnotation
	/ MarkerAnnotation

NormalAnnotation
	= "@" _ { @TypeName _ "(" _ (@ElementValuePairList)? _ ")" #NormalAnnotation } _

MarkerAnnotation
	= "@" _ { @TypeName #MarkerAnnotation }

SingleElementAnnotation
	= "@" _ { @TypeName _ "(" _ @ElementValue _ ")" #SingleElementAnnotation } _

ElementValuePairList
	= { @ElementValuePair ( _ "," _ @ElementValuePair)* #ElementValuePairList }

ElementValuePair
	= { @Name _ "=" _ @ElementValue #ElementValuePair }

ElementValue
	= ElementValueArrayInitializer
	/ ConditionalExpression
	/ Annotation

ElementValueArrayInitializer
	= "{" _ { (@ElementValueList)? #ElementValueArrayInitializer } _ ","? "}" _

ElementValueList
	= { @ElementValue ( _ "," _ @ElementValue)* #ElementValueList}


// Declaration
//==============

//local variable
VariableDeclaration
	= { (@VariableModifier)* @Type @InitDecl ("," _ @InitDecl)* #Declaration }

VariableModifier
	= Annotation
	/ "final" _ { #KeyValue @{`abstraction` #Key } @{`final` #Value } } _

InitDecl
	= { @VarName ("=" _ @Initializer)? #VarDecl } _

InitDeclAssign
	= { @VarName "=" _ @Initializer #VarDecl } _

VarName
	= Name {@ "[" _ (@ConstantExpression)? "]" _ #ArrayName }*

Initializer
	= Expression
	/ ArrayInitializer

ArrayInitializer
	= { "{" _ arrayInitializeExpressionList? _ ","? "}" #ArrayInitializer } _

arrayInitializeExpressionList
	= (@Initializer ("," _ @Initializer)*)

//class type, enum type
ClassDeclaration
	= { (@ClassModifier)* "class" _ @Name (@TypeParameters)? (@SuperClass)? (@SuperInterfaces)* @ClassBody #ClassDeclaration } _
	/ { (@ClassModifier)* "enum" _ @Name (@SuperInterfaces)* @EnumBody #EnumDeclaration } _

ClassModifier
	= Annotation
	/ "public"    _ { #KeyValue @{`visibility`  #Key } @{`public`    #Value } } _
	/ "protected" _ { #KeyValue @{`visibility`  #Key } @{`protected` #Value } } _
	/ "private"   _ { #KeyValue @{`visibility`  #Key } @{`private`   #Value } } _
	/ "abstract"  _ { #KeyValue @{`abstraction` #Key } @{`abstract`  #Value } } _
	/ "final"     _ { #KeyValue @{`abstraction` #Key } @{`final`     #Value } } _
	/ "static"    _ { #KeyValue @{`static`      #Key } @{`true`      #Value } } _
	/ "strictfp"  _ { #KeyValue @{`strictfp`    #Key } @{`true`      #Value } } _

SuperClass
	= { "extends" _ @ClassOrInterfaceType #SuperClass } _

SuperInterfaces
	= { "implements" _ @ClassOrInterfaceTypes #SuperInterfaces } _

EnumBody
	= "{" _ { (@EnumeratorList)? ","? ";" _ (@ClassBodyDeclaration)+ #EnumBody } _ "}" _
	/ "{" _ { (@EnumeratorList)? ","? ";"? #EnumBody } _ "}" _

EnumeratorList
	= { @Enumerator ("," _ @Enumerator)* #List }

Enumerator
	= { (@Annotation)* @Name (@{ "(" _ addArgumentExpressionList? ")" #List } _ )? (@ClassBody)? #Enumerator }

ClassBody
	= "{" _ { (@ClassBodyDeclaration)* #ClassBody } "}" _

ClassBodyDeclaration
	= ClassMemberDeclaration
	/ { @Block #InstanceInisializer } _
	/ "static" _ { @Block #StaticInitializer } _
	/ ConstructorDeclaration

ClassMemberDeclaration
	= FieldDeclaration
	/ MethodDeclaration
	/ ClassDeclaration
	/ InterfaceDeclaration
	/ { ";" #Empty } _

//interface, annotation type
InterfaceDeclaration
	= { (@InterfaceModifier)* "interface" _ @Name (@TypeParameters)? (@ExtendsInterfaces)* @InterfaceBody #InterfaceDeclaration } _
	/ { (@InterfaceModifier)* "@" _ "interface" _ @Name @AnnotationTypeBody #AnnotationTypeDeclaration } _

InterfaceModifier
	= Annotation
	/ "public"    _ { #KeyValue @{`visibility`  #Key } @{`public`    #Value } } _
	/ "protected" _ { #KeyValue @{`visibility`  #Key } @{`protected` #Value } } _
	/ "private"   _ { #KeyValue @{`visibility`  #Key } @{`private`   #Value } } _
	/ "abstract"  _ { #KeyValue @{`abstraction` #Key } @{`abstract`  #Value } } _
	/ "static"    _ { #KeyValue @{`static`      #Key } @{`true`      #Value } } _
	/ "strictfp"  _ { #KeyValue @{`strictfp`    #Key } @{`true`      #Value } } _

ExtendsInterfaces
	= { "extends" _ @ClassOrInterfaceTypes #ExtendsInterfaces } _

InterfaceBody
	= "{" _ { (@InterfaceMemberDeclaration)* #InterfaceBody } "}" _

InterfaceMemberDeclaration
	= ConstantDeclaration
	/ InterfaceMethodDeclaration
	/ ClassDeclaration
	/ InterfaceDeclaration
	/ { ";" #Empty } _

AnnotationTypeBody
	= "{" _ { (@AnnotationTypeMemberDeclaration)* #AnnotationTypeBody } "}" _

AnnotationTypeMemberDeclaration
	= AnnotationTypeElementDeclaration
	/ ConstantDeclaration
	/ ClassDeclaration
	/ InterfaceDeclaration
	/ { ";" #Empty } _

AnnotationTypeElementDeclaration
	= { (@AnnotationTypeElementModifier)* @Type @Name "(" _ ")" _ (@AnnotationTypeElementDefaultValue)? ";" #AnnotationTypeElement } _

AnnotationTypeElementModifier
	= Annotation
	/ "public"   _ { #KeyValue @{`visibility`  #Key } @{`public`   #Value } } _
	/ "abstract" _ { #KeyValue @{`abstraction` #Key } @{`abstract` #Value } } _

AnnotationTypeElementDefaultValue
	= "default" _ ElementValue


//field, constant
FieldDeclaration
	= { (@FieldModifier)* @Type @InitDecl ("," _ @InitDecl)*  ";" #Field } _

FieldModifier
	= Annotation
	/ "public"    _ { #KeyValue @{`visibility` #Key } @{`public`    #Value } } _
	/ "protected" _ { #KeyValue @{`visibility` #Key } @{`protected` #Value } } _
	/ "private"   _ { #KeyValue @{`visibility` #Key } @{`private`   #Value } } _
	/ "final"     _ { #KeyValue @{`final`      #Key } @{`true`      #Value } } _
	/ "static"    _ { #KeyValue @{`static`     #Key } @{`true`      #Value } } _
	/ "transient" _ { #KeyValue @{`transient`  #Key } @{`true`      #Value } } _
	/ "volatile"  _ { #KeyValue @{`volatile`   #Key } @{`true`      #Value } } _

ConstantDeclaration
	= { (@ConstantModifier)* @Type @InitDecl ("," _ @InitDecl)*  ";" #Constant } _

ConstantModifier
	= Annotation
	/ "public" _ { #KeyValue @{`visibility` #Key } @{`public` #Value } } _
	/ "final"  _ { #KeyValue @{`final`      #Key } @{`true`   #Value } } _
	/ "static" _ { #KeyValue @{`static`     #Key } @{`true`   #Value } } _

//method
MethodDeclaration
	= { (@MethodModifier)* (@TypeParameters (@Annotation)*)? @TypeOrVoid @Name "(" _ @MethodParamList ")" _ (@Throws)? (@Block / ";" _ ) #Method } _

MethodModifier
	= Annotation
	/ "public"       _ { #KeyValue @{`visibility`   #Key } @{`public`    #Value } } _
	/ "protected"    _ { #KeyValue @{`visibility`   #Key } @{`protected` #Value } } _
	/ "private"      _ { #KeyValue @{`visibility`   #Key } @{`private`   #Value } } _
	/ "abstract"     _ { #KeyValue @{`abstraction`  #Key } @{`abstract`  #Value } } _
	/ "final"        _ { #KeyValue @{`abstraction`  #Key } @{`final`     #Value } } _
	/ "static"       _ { #KeyValue @{`static`       #Key } @{`true`      #Value } } _
	/ "synchronized" _ { #KeyValue @{`synchronized` #Key } @{`true`      #Value } } _
	/ "native"       _ { #KeyValue @{`native`       #Key } @{`true`      #Value } } _
	/ "strictfp"     _ { #KeyValue @{`strictfp`     #Key } @{`true`      #Value } } _

InterfaceMethodDeclaration
	= { (@InterfaceMethodModifier)* (@TypeParameters (@Annotation)*)? @TypeOrVoid @Name "(" _ @MethodParamList ")" _ (@Throws)? (@Block / ";" _ ) #Method } _

InterfaceMethodModifier
	= Annotation
	/ "public"   _ { #KeyValue @{`visibility`  #Key } @{`public`   #Value } } _
	/ "abstract" _ { #KeyValue @{`abstraction` #Key } @{`abstract` #Value } } _
	/ "default"  _ { #KeyValue @{`abstraction` #Key } @{`default`  #Value } } _
	/ "static"   _ { #KeyValue @{`static`      #Key } @{`true`     #Value } } _
	/ "strictfp" _ { #KeyValue @{`strictfp`    #Key } @{`true`     #Value } } _

MethodParamList
	= { (@MethodParam "," _ )* @VarArgs #List }
	/ { ( @MethodParam ("," _ @MethodParam)* )? #List }

MethodParam
	= { (@VariableModifier)* @Type _ @VarName #Param } _

VarArgs
	= { @Type _ "..." _ @VarName #VarArgs }

Throws
	= "throws" _ { @ClassOrInterfaceTypes #Throws } _

//constructor
ConstructorDeclaration
	= { (@ConstructorModifier)* @ReferenceType "(" _ @MethodParamList ")" _ (@Throws)? @ConstructorBody #Constructor } _

ConstructorModifier
	= Annotation
	/ "public"    _ { #KeyValue @{`visibility` #Key } @{`public`    #Value } } _
	/ "protected" _ { #KeyValue @{`visibility` #Key } @{`protected` #Value } } _
	/ "private"   _ { #KeyValue @{`visibility` #Key } @{`private`   #Value } } _

ConstructorBody
	= { "{" _ (@ExplicitConstructorInvocation)? (@Statement / @LocalDeclaration)* "}" #Block } _

ExplicitConstructorInvocation
	= { (@TypeArguments)? @{ "this" _  "(" _ addArgumentExpressionList? ")" #List } #ExplicitConstructorInvocation  } _ ";" _
	/ { (@TypeArguments)? @{ "super" _ "(" _ addArgumentExpressionList? ")" #List } #ExplicitConstructorInvocation  } _ ";" _
//	/ { @PrimaryExpression '.' (@TypeArguments)? "super" _ @{ "(" _ addArgumentExpressionList? ")" #List } #ExplicitConstructorInvocation  } _ ";" _
//	/ { @TypeName '.' (@TypeArguments)? "super" _ @{ "(" _ addArgumentExpressionList? ")" #List } #ExplicitConstructorInvocation  } _ ";" _


//Type
//====

Type
	= ReferenceType / PrimaryType

TypeOrVoid
	= Type / Void

Type_noArray
	= ClassOrInterfaceType / PrimaryType

TypeName
	= Name {@ _ "." _ @Name #TypeName }*

ReferenceType
	= ArrayType
	/ ClassOrInterfaceType

ArrayType
	= (PrimaryType / ClassOrInterfaceType) {@ "[" _ "]" _ #TArray }+

ClassOrInterfaceType
	= { @TypeName @TypeArguments #TGenerics } _
	/ TypeName _

ClassOrInterfaceTypes
	= { @ClassOrInterfaceType ("," _ @ClassOrInterfaceType)* #TypeList }

TypeParameters
	= { "<" _ @TypeParameter ("," _ @TypeParameter)* ">" #TypeParameters } _

TypeParameter
	= ReferenceType {@ _ "extends" _ @ReferenceType ("&" _ @ReferenceType)* #SuperTypes }?

TypeArguments
	= { "<" _ @TypeArgument ("," _ @TypeArgument)* ">" #TypeArguments } _
	/ { "<" _ ">" #Diamond } _

TypeArgument
	= ReferenceType
	/ { "?" #TWildCard } {@ _ ("extends" #UpperBound / "super" #LowerBound) _ @ReferenceType }?

PrimaryType
	= { "byte"    #TInt }     _
	/ { "char"    #TInt }     _
	/ { "short"   #TInt }     _
	/ { "int"     #TInt }     _
	/ { "long"    #TInt }     _
	/ { "float"   #TFloat }   _
	/ { "double"  #TFloat }   _
	/ { "boolean" #TBoolean } _

Void
	= { "void" #TVoid } _


// Block, Statement
//===================

Block
	= { "{" _ (@Statement / @LocalDeclaration)* "}" #Block } _

LocalDeclaration
	= VariableDeclaration ";" _
	/ ClassDeclaration

Statement
	= Block
	/ { "assert" _ @Expression (":" _ @Expression)? ";" #Assert } _
	/ { "if" _   "(" _ @Expression ")" _ @Statement ("else" _ @Statement)? #If }
	/ { "switch" _ "(" _ @Expression ")" _ @Statement #Switch }
	/ { "while" _  "(" _ @Expression ")" _ @Statement #While }
	/ { "do" _ @Statement "while" _ "(" _ @Expression ")" _ ";" #DoWhile } _
	/ { "for" _ "(" _ (@Expressions)?      ";" _ (@Expression)? ";" _ (@Expressions)? ")" _ @Statement #For }
	/ { "for" _ "(" _ @VariableDeclaration ";" _ (@Expression)? ";" _ (@Expressions)? ")" _ @Statement #For }
	/ { "for" _ "(" _ (@VariableModifier)* @Type @Name ":" _ @Expression ")" _ @Statement #ForEach }
	/ { "goto" _ @Name ";" #Goto } _
	/ { "continue" _ ";" #Continue } _
	/ { "break" _ ";" #Break } _
	/ { "return" _ (@Expression)?  ";" #Return } _
	/ { "try" _ @ResourceStatement @Block (@CatchBlock)* (@{ "finally" _ @Block #Finally })? #Try }
	/ { "try" _ @Block (@CatchBlock)* @{ "finally" _ @Block #Finally } #Try }
	/ { "try" _ @Block (@CatchBlock)+ #Try }
	/ { "throw" _ @Expression ";" #Throw } _
	/ { "case" _ @ConstantExpression ":" _ (!"case" _ !"default" _ @Statement)* #SwitchCase }
	/ { "default" _ ":" _ (!"case" _ @Statement)* #SwitchDefault }
	/ { @Name ":" #Label } _
	/ { @Expression ";" #ExpressionStatement } _
	/ { ";" #Empty } _

//trycatch
ResourceStatement
	= "(" _ { @Resource _ (";" _ @Resource _ )* #ResourceList } ";"? ")" _

Resource
	= { (@VariableModifier)* @Type @Name "=" _ @Expression #Declaration }

CatchBlock
	= { "catch" _ "(" _ @CatchParameter ")" _ @Block #Catch }

CatchParameter
	= { (@VariableModifier)* @ClassOrInterfaceType @Name ("|" _ @Name)* #Declaration }


//Expression
//==========

Expression
	= LambdaExpression
	/ AssignmentExpression

Expressions
	= { @Expression ("," _ @Expression)* #Expressions }

AssignmentExpression
	= { @UnaryExpression addAssignmentOperator _ @Expression }
	/ ConditionalExpression

addAssignmentOperator
	= "="    #Assign
	/ "*="   #AssignMul
	/ "/="   #AssignDiv
	/ "%="   #AssignMod
	/ "+="   #AssignAdd
	/ "-="   #AssignSub
	/ "<<="  #AssignLeftShift
	/ ">>="  #AssignArithmeticRightShift
	/ ">>>=" #AssignLogicalRightShift
	/ "&="   #AssignBitwiseAnd
	/ "^="   #AssignBitwiseXOr
	/ "|="   #AssignBitwiseOr

ConstantExpression
	= ConditionalExpression

ConditionalExpression
	= LogicalORExpression {@ "?" _  @Expression ":" _ @LogicalORExpression #Trinary }*

LogicalORExpression
	= LogicalANDExpression {@ "||" _ @LogicalANDExpression #Or }*

LogicalANDExpression
	= InclusiveORExpression {@ "&&" _ @InclusiveORExpression #And }*

InclusiveORExpression
	= ExclusiveORExpression {@ "|" _ @ExclusiveORExpression #BitwiseOr }*

ExclusiveORExpression
	= ANDExpression {@ "^" _ @ANDExpression #BitwiseXor }*

ANDExpression
	= EqualityExpression {@ "&" _ @EqualityExpression #BitwiseAnd }*

EqualityExpression
	= RelationalExpression {@ ( "==" #Equals / "!=" #NotEquals ) _ @RelationalExpression }*

relationalOperator
	= "<=" #LessThanEquals
	/ ">=" #GreaterThanEquals
	/ "<"  #LessThan
	/ ">"  #GreaterThan

RelationalExpression
	= ShiftExpression {@ ( relationalOperator _ @ShiftExpression / "instanceof" _ @ReferenceType #InstanceOf ) }*

ShiftExpression
	= AdditiveExpression {@ ( "<<" #LeftShift / ">>" #ArithmeticRightShift / ">>>" #LogicalRightShift ) _ @AdditiveExpression }*

AdditiveExpression
	= MultiplicativeExpression {@ ( "+" #Add / "-" #Sub ) _ @MultiplicativeExpression }*

MultiplicativeExpression
	= CastNewExpression {@ ( "*" #Mul / "/" #Div / "%" #Mod ) _ @CastNewExpression }*

CastNewExpression
	= { "(" _ @Type ")" _ @CastNewExpression #Cast }
	/ UnaryExpression

UnaryExpression
	= PostfixExpression
	/ { "++" _ @UnaryExpression #PrefixInc }
	/ { "--" _ @UnaryExpression #PrefixDec }
	/ { "+"  _ @CastNewExpression #Plus }
	/ { "-"  _ @CastNewExpression #Minus }
	/ { "~"  _ @CastNewExpression #Compl }
	/ { "!"  _ @CastNewExpression #Not }

PostfixExpression
	= (PrimaryExpression / InstanceCreationExpression / ArrayCreationExpression)
		{@ (addMethodCall _ / addIndex _ / addField / addMethodReference / addInc _ / addDec _ ) }*

InstanceCreationExpression
	= { "new" _ (@TypeArguments)? (@Annotation)* @ClassOrInterfaceType @{ "(" _ addArgumentExpressionList? ")" #List } _ (@ClassBody)? #InstanceCreation }

ArrayCreationExpression
	= { "new" _ (@Annotation)* @((PrimaryType / ClassOrInterfaceType) {@ (@Annotation)* "[" _ @Expression "]" _ #ArraySize }+) #ArrayCreation }
	/ { "new" _ (@Annotation)* @((PrimaryType / ClassOrInterfaceType) {@ (@Annotation)* "[" _ "]" _ #ArraySize }+) @ArrayInitializer #ArrayCreation }

addMethodCall
	= "." _ (@TypeArguments)? @Name @{ "(" _ addArgumentExpressionList? ")" #List } #Method
	/ @{ "(" _ addArgumentExpressionList? ")" #List } #Method

addArgumentExpressionList
	= (@Expression ("," _ @Expression)*)

addIndex
	= "[" _ @Expression "]" #Index

addField
	= "." _ @Name !'(' #Field

addMethodReference
	= "::" _ @(Name / { "new" #New } _ ) #MethodReference

addInc
	= "++" #Inc

addDec
	= "--" #Dec

PrimaryExpression
	= Constant
	/ "(" _ Expression ")" _
	/ { "this" #This } _
	/ { "super" #Super } _
	/ { @TypeOrVoid "." _ "class" #Class } _
	/ Name

LambdaExpression
	= { @LambdaParameters _ "->" _ @LambdaBody #LambdaExpression }

LambdaParameters
	= { (@Name
		/ @{ "(" _ addArgumentExpressionList? _ ")" #AddArgumentExpressionList } _
		/ "(" _ @InferredFormalParameterList _ ")" _
		) #LambdaParameters }

InferredFormalParameterList
	= { @Name ( _ "," _ @Name)* #InferredFormalParameterList }

LambdaBody
	= { (@Expression / @Block) #LambdaBody }


//Literal
//=======

Constant
	= JavaFloat
	/ JavaInteger
	/ JavaBoolean
	/ JavaString
	/ JavaChar
	/ JavaNull

JavaFloat
	= { FLOAT #Float } FLOAT_SUFFIX? _

FLOAT
	= FRACTION EXPONENT?
	/ DIGIT+ EXPONENT

FRACTION
	= !'_' ('_'* DIGIT)* '.' DIGIT ('_'* DIGIT)*
	/ DIGIT ('_'* DIGIT)* '.'

EXPONENT
	= [eE] [+\-]? DIGIT ('_'* DIGIT)*

FLOAT_SUFFIX
	= [fFdD]

JavaInteger
	= { ( DECIMAL / HEXADECIMAL ) #Integer } INT_SUFFIX? _
//	= { ( BINARY / DECIMAL / HEXADECIMAL / OCTAL ) #Integer } INT_SUFFIX? _

BINARY
	= BIN_PREFIX [01] ('_'* [01])*

BIN_PREFIX
	= '0' [bB]

DECIMAL
	= '0' ![0-9xXbB]
	/ [1-9] ('_'* DIGIT)*

HEXADECIMAL
	= HEX_PREFIX HEX ('_'* HEX)*

HEX_PREFIX
	= '0' [xX]

OCTAL
	= '0' ('_'* [0-7])*

INT_SUFFIX
	= [lL]

JavaBoolean
	= { "true"  #True }  _
	/ { "false" #False } _

JavaString
	= '"' { STRING_CONTENT* #String } '"' _

JavaChar
	= '\'' { CHAR_CONTENT* #Character } '\'' _

STRING_CONTENT
	= ESCAPE
	/ ![\"\n\\] .

CHAR_CONTENT
	= ESCAPE
	/ !['\n\\] .

ESCAPE
	= SIMPLE_ESCAPE
	/ OCTAL_ESCAPE
	/ HEX_ESCAPE

SIMPLE_ESCAPE
	= '\\' ['\"\\bfnrt]

OCTAL_ESCAPE
	= '\\' [0-3] [0-7] [0-7]
	/ '\\' [0-7] [0-7]
	/ '\\' [0-7]

HEX_ESCAPE
	= '\\' 'u'+ HEX4

JavaNull
	= { "null" #Null } _
