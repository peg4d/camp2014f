// PEG4d Java8 Grammar
// ===============

export
	= Statement
	/ Expression
	/ CInteger
	/ CFloat
	/ CString
	/ CChar

File
	= _ { ( @TopLevel / _ )* #Source } EOT

Chunk
	= TopLevel
	/ Statement
	/ Expression
	/ Type
_
	= (S / BLOCKCOMMENT / LINECOMMENT )*

S
	= [ \n\r\t\u000B\u000C]

BLOCKCOMMENT
	= '/*' (!'*/' .)* '*/'

LINECOMMENT
	= '//' (!'\n' .)*

//PRAGMA
//	= '#' (!'\n' .)*

EOL
	= ('\r'? '\n' / !.)

DIGIT
	= [0-9]

W
	= [a-zA-Z0-9_$]
	/ UCHAR

UCHAR
	= '\\u' HEX4
	/ '\\U' HEX4 HEX4

HEX4
	= HEX HEX HEX HEX

Name
	= { NAME #Name } _ 

NAME
	= !DIGIT !(KEYWORD !W) W+

KEYWORD
	= 'abstract' / 'assert' / 'boolean' / 'break' / 'byte' / 'case'
	/ 'catch' / 'char' / 'class' / 'const' / 'continue' / 'default'
	/ 'do' / 'double' / 'else' / 'enum' / 'extends' / 'false'
	/ 'final' / 'finally' / 'float' / 'for' / 'goto' / 'if' / 'implements'
	/ 'import' / 'instanceof' / 'int' / 'interface' / 'long' / 'native'
	/ 'new' / 'null' / 'package' / 'private' / 'protected' / 'public'
	/ 'return' / 'short' / 'static' / 'strictfp' / 'super' / 'switch'
	/ 'synchronized' / 'this' / 'throw' / 'throws' / 'transient'
	/ 'true' / 'try' / 'void' / 'volatile' / 'while'

"++"     = '++' _
"--"     = '--' _
"&"     = '&' !'&' _
"*"    = '*' !'=' _
"+"    = '+' ![+=] _
"-"   = '-' !('-' / [=>]) _
"~"   = '~' _
"!"    = '!' !'=' _
"char"      = 'char'     !W
"short"     = 'short'    !W
"int"       = 'int'      !W
"long"      = 'long'     !W
"float"     = 'float'    !W
"double"    = 'double'   !W
"boolean"   = 'boolean'  !W
"byte"      = 'byte'     !W
"{"     = '{' _
"["      = '[' _
"]"      = ']' _
","	  = ',' _
"..."	= '...' _
":"	= ':' ![>] _
"/"	= '/' !'=' _
"%"	= '%' ![=>] _
"<<"	= '<<' !'=' _
">>"	= '>>' !'=' _
"<="	= '<=' _
">="	= '>=' _
"<"	= '<' ![=] _
">"	= '>' ![=] _
"=="	= '==' _
"!="	= '!=' _
"^"	= '^' ![=] _
"|"	= '|' ![=] _
"&&"	= '&&' _
"||"	= '||' _
"?"	= '?' _
";"	= (';' _ / EOL)  /* this is for debug */
"}"	= '}' _
"enum"	= 'enum' !W
"case"	= 'case' !W
"default"	= 'default' !W
"if"	= 'if' !W
"else"	= 'else' !W
"switch"	= 'switch' !W
"while"	= 'while' !W
"do"	= 'do' !W
"for"	= 'for' !W
"goto"	= 'goto' !W
"continue"	= 'continue' !W
"break"	= 'break' !W
"return"	= 'return' !W
"*="	= '*=' _
"/="	= '/=' _
"%="	= '%=' _
"+="	= '+=' _
"-="	= '-=' _
"<<="	= '<<=' _
">>="	= '>>=' _
"&="	= '&=' _
"^="	= '^=' _
"|="	= '|=' _
"="	= '=' !'=' _
"."	= '.' _
"static"	= 'static' !W _
"volatile"	= 'volatile' !W _



"("	= '(' _
")"	= ')' _

EOT	= !.

TopLevel
	= PackageDeclaration
	/ ImportDeclaration
	/ ClassDeclaration


// package definition
PackageDeclaration
	= { (@PackageModifier)* _ 'package' _ @Name _ ( '.' _ @Name _ )* ";" #PackageDeclaration }

PackageModifier
	= Annotation

// import definition
ImportDeclaration
	= TypeImportOnDemandDeclaration
	/ SingleImportDeclaration
	/ StaticImportOnDemandDeclaration
	/ SingleStaticImportDeclaration

SingleTypeImportDeclaration
	= 'import' _ { @TypeName #SingleTypeImportDeclaration } _ ";"

TypeImportOnDemandDeclaration
	= 'import' _ { @TypeName  _ '.' _ '*' #TypeImportOnDemandDeclaration } _ ";"

SingleStaticImportDeclaration
	= 'import' _ 'static'  _ { @TypeName _ '.' _ @Name #SingleStaticImportDeclaration } _ ';'

StaticImportOnDemandDeclaration
	= 'import' _ 'static' _ { @TypeName #StaticImportOnDemandDeclaration } _ '.' _ '*' _ ';'

TypeName
	= { @Name ( _ '.' _ @Name #TypeName) }

// annotation definition
Annotation
	= NormalAnnotation
	/ SingleElementAnnotation
	/ MarkerAnnotation

NormalAnnotation
	= '@' _ { @TypeName _ '(' _ (@ElementValuePairList)? _ ')' #NormalAnnotation }

MarkerAnnotation
	= '@' _ { @TypeName #MarkerAnnotation }

SingleElementAnnotation
	= '@' _ { @TypeName _ '(' _ @ElementValue _ ')' #SingleElementAnnotation }

ElementValuePairList
	= { @ElementValuePair ( _ ',' _ @ElementValuePair)* #ElementValuePairList }

ElementValuePair
	= { @Name _ '=' _ @ElementValue #ElementValuePair }

ElementValue
	= ElementValueArrayInitializer
//	/ conditionalExpression
	/ Annotation

ElementValueArrayInitializer
	= '{' _ { (@ElementValueList)? #ElementValueArrayInitializer } _ ','? _ '}'

ElementValueList
	= { @ElementValue ( _ ',' _ @ElementValue)* #ElementValueList}


	
// Declaration
//==============

VariableDeclaration
	= { (@Annotation)* @Type @InitDecl ("," @InitDecl)*  ";" #Declaration }

InitDecl
	= { @VarName ("=" @Initializer)? #VarDecl } _

InitDeclAssign
	= { @VarName "=" @Initializer #VarDecl } _

VarName
	= { "*" @VarName #PointerName } _
	/ Name {@ "[" (@ConstantExpression)? "]" #ArrayName}*

Initializer
	= AssignmentExpression
	/ "{" { (addInitializerList)* ","? #Initializer } "}"

addInitializerList
	= (@Designation / @Initializer)? ("," (@Designation / @Initializer))*

Designation
	= { (@Designator)+ "=" @Initializer  #Designation }
	
Designator
	= "[" ConstantExpression "]"
	/ "." Name _


//Type
//====

Type
	= ({ @PrimaryType @TGenerics #TGenerics } / PrimaryType) {@ "[" _? "]" #TArray }*

TGenerics
	= { '<' @Type ("," @Type)* '>' #Generics } _

PrimaryType
	= { "byte"         #TInt } _
	/ { "char"         #TInt } _
	/ { "short"        #TInt } _
	/ { "int"          #TInt } _
	/ { "long"         #TInt } _
	/ { "float"       _   #TFloat } _
	/ { "double"      _   #TFloat } _
	/ { "boolean"  #TBoolean } _
	/ { NAME   #Name } _

//class
ClassDeclaration
	= { (@ClassModifier)* "class" @Name (@TGenerics)? (@SuperClass)? (@SuperInterfaces)* @ClassBody #TClass } _
	/ { (@ClassModifier)* "enum" @Name (@SuperInterfaces)* @EnumBody #TEnum } _

ClassModifier
	= Annotation
	/ 'public'    _ { #KeyValue @{`visibility` #Key } @{`public` #Value } } _
	/ 'protected' _ { #KeyValue @{`visibility` #Key } @{`protected` #Value } } _
	/ 'private'   _ { #KeyValue @{`visibility` #Key } @{`private` #Value } } _
	/ 'abstract'  _ { #KeyValue @{`abstraction` #Key } @{`abstract` #Value } } _
	/ 'final'     _ { #KeyValue @{`abstraction` #Key } @{`final` #Value } } _
	/ 'static'    _ { #KeyValue @{`static` #Key } @{`true` #Value } } _
	/ 'strictfp'  _ { #KeyValue @{`strictfp` #Key } @{`true` #Value } } _

SuperClass
	= { 'extends' _ @Type #SuperClass } _

SuperInterfaces
	= { 'implements' _ @Type ("," @Type)* #SuperInterfaces } _

EnumBody
	= '{' _ { (@EnumeratorList)? ","? ";" (@ClassBodyDeclaration)? #EnumBody } _ "}"

EnumeratorList
	= { @Enumerator ("," @Enumerator)* #List }

Enumerator
	= { (@Annotation)* @Name (@{ "(" addArgumentExpressionList ")" #List })? (@ClassBody)? #Enumerator }

ClassBody
	= '{' _ { (@ClassBodyDeclaration)+ #ClassBody } "}"

ClassBodyDeclaration
	= ClassMemberDeclaration
	/ { @Block #InstanceInisializer } _
	/ 'static' _ { @Block #StaticInitializer } _
//	/ ConstructorDeclaration

ClassMemberDeclaration
	= FieldDeclaration
	/ MethodDeclaration
	/ ClassDeclaration
//	/ InterfaceDeclaration

FieldDeclaration
	= { (@FieldModifier)* @Type @InitDecl ("," @InitDecl)*  ";" #Field } _

FieldModifier
	= Annotation
	/ 'public'    _ { #KeyValue @{`visibility` #Key } @{`public` #Value } } _
	/ 'protected' _ { #KeyValue @{`visibility` #Key } @{`protected` #Value } } _
	/ 'private'   _ { #KeyValue @{`visibility` #Key } @{`private` #Value } } _
	/ 'final'     _ { #KeyValue @{`final` #Key } @{`true` #Value } } _
	/ 'static'    _ { #KeyValue @{`static` #Key } @{`true` #Value } } _
	/ 'transient' _ { #KeyValue @{`transient` #Key } @{`true` #Value } } _
	/ 'volatile'  _ { #KeyValue @{`volatile` #Key } @{`true` #Value } } _

MethodDeclaration
	= { (@MethodModifier)* @Type @Name "(" @MethodParamList ")" (@Block / ";") #Method } _

MethodModifier
	= Annotation
	/ 'public'       _ { #KeyValue @{`visibility` #Key } @{`public` #Value } } _
	/ 'protected'    _ { #KeyValue @{`visibility` #Key } @{`protected` #Value } } _
	/ 'private'      _ { #KeyValue @{`visibility` #Key } @{`private` #Value } } _
	/ 'abstract'     _ { #KeyValue @{`abstraction` #Key } @{`abstract` #Value } } _
	/ 'final'        _ { #KeyValue @{`abstraction` #Key } @{`final` #Value } } _
	/ 'static'       _ { #KeyValue @{`static` #Key } @{`true` #Value } } _
	/ 'synchronized' _ { #KeyValue @{`synchronized` #Key } @{`true` #Value } } _
	/ 'native'       _ { #KeyValue @{`native` #Key } @{`true` #Value } } _
	/ 'strictfp'     _ { #KeyValue @{`strictfp` #Key } @{`true` #Value } } _

MethodParamList
	= { ( @MethodParam ("," @MethodParam)* )? ("," "...")? #List } 

MethodParam
	= { @Type _ @VarName #Param} _

ConstructorDeclaration
	= { (@ConstructorModifier)* @Type "(" @MethodParamList ")" @Block #Constructor } _

ConstructorModifier
	= Annotation
	/ 'public'       _ { #KeyValue @{`visibility` #Key } @{`public` #Value } } _
	/ 'protected'    _ { #KeyValue @{`visibility` #Key } @{`protected` #Value } } _
	/ 'private'      _ { #KeyValue @{`visibility` #Key } @{`private` #Value } } _

//ExplicitConstructorInvocation
//	= @{ 'this' _ @{ "(" addArgumentExpressionList ")" #List } #ConstructorInvocation  } ";"
//	/ @{ 'super' _ @{ "(" addArgumentExpressionList ")" #List } #ConstructorInvocation  } ";"
//	/ @{ 'super' _ @{ "(" addArgumentExpressionList ")" #List } #ConstructorInvocation  } ";"
//	/ @{ 'super' _ @{ "(" addArgumentExpressionList ")" #List } #ConstructorInvocation  } ";"


// Block, Statement
//===================

Block
	= { "{" (@Statement / @Declaration)* "}" #Block }

Statement
	= Block
	/ { "if"   "(" @Expression ")" @Statement ("else" @Statement)? #If }
	/ { "switch" "(" @Expression ")" @Statement #Switch }
	/ { "while"  "(" @Expression ")" @Statement #While }
	/ { "do" @Statement "while" "(" @Expression ")" ";" #DoWhile }
	/ { "for" "(" (@Expression)? ";" (@Expression)? ";" (@Expression)? ")" @Statement #For }
	/ { "for" "(" @Declaration (@Expression)? ";" (@Expression)? ";" @Statement #For }
	/ { "goto" @Name ";" #Goto }
	/ { "continue" ";" #Continue }
	/ { "break" ";" #Break }
	/ { "return" (@Expression)?  ";" #Return }
	/ { "case" @ConstantExpression ":" (!"case" !"default" @Statement)* #SwitchCase }
	/ { "default" ":" (!"case" @Statement)* #SwitchDefault }
	/ { @Name ":" #Label }
	/ { @Expression ";" #ExpressionStatement }
	/ { #Empty } ";"


//Expression
//==========

Expression
	= AssignmentExpression {@ "," @AssignmentExpression #Expression }*

AssignmentExpression
	= { @UnaryExpression addAssignmentOperator @AssignmentExpression }
	/ ConditionalExpression

addAssignmentOperator
	= "="        #Assign
	/ "*="    #AssignMul
	/ "/="     #AssignDiv
	/ "%="     #AssignMod
	/ "+="    #AssignAdd
	/ "-="   #AssignSub
	/ "<<="    #AssignLeftShift
	/ ">>="   #AssignRightShift
	/ "&="     #AssignBitwiseAnd
	/ "^="     #AssignBitwiseXOr 
	/ "|="      #AssignBitwiseOr

ConstantExpression
	= ConditionalExpression
	
ConditionalExpression
	= LogicalORExpression {@ "?"  @Expression ":" @LogicalORExpression #Trinary }*

LogicalORExpression
	= LogicalANDExpression {@ "||" @LogicalANDExpression #Or }*

LogicalANDExpression
	= InclusiveORExpression {@ "&&" @InclusiveORExpression #And }*

InclusiveORExpression
	= ExclusiveORExpression {@ "|" @ExclusiveORExpression #BitwiseOr }*

ExclusiveORExpression
	= ANDExpression {@ "^" @ANDExpression #BitwiseXor }*

ANDExpression
	= EqualityExpression {@ "&" @EqualityExpression #BitwiseAnd }*

EqualityExpression
	= RelationalExpression {@ ( "==" #Equals / "!=" #NotEquals ) @RelationalExpression }*
	
RelationalExpression
	= ShiftExpression {@ ( "<=" #LessThanEquals / ">=" #GreaterThanEquals / "<" #LessThan / ">" #GreaterThan ) @ShiftExpression }*
	
ShiftExpression
	= AdditiveExpression {@ ( "<<" #LeftShift / ">>" #RightShift ) @AdditiveExpression }*
	
AdditiveExpression
	= MultiplicativeExpression {@ ( "+" #Add / "-" #Sub ) @MultiplicativeExpression }*
	
MultiplicativeExpression
	= CastExpression {@ ( "*" #Mul / "/" #Div / "%" #Mod ) @CastExpression }*

UnaryExpression
	= PostfixExpression
	/ { "++"    @UnaryExpression #PrefixInc }
	/ { "--"    @UnaryExpression #PrefixDec }
	/ { "&"    @CastExpression #Address }
	/ { "*"   @CastExpression #Star }
	/ { "+"   @CastExpression #Plus }
	/ { "-"  @CastExpression #Minus }
	/ { "~"  @CastExpression #Compl }
	/ { "!"   @CastExpression #Not }
	/ { "sizeof"  ( @UnaryExpression / "(" @Type ")" ) #SizeOf }

CastExpression
	= { "(" @Type ")" @CastExpression #Cast }
	/ UnaryExpression

PostfixExpression
	= ( PrimaryExpression / { "(" @Type ")" "{" @{ (addInitializerList)* ","? #Initializer } "}" } ) 
	{@ (addFunctionCall / addIndex / addField / addInc / addDec) }*

addFunctionCall
	= @{ "(" addArgumentExpressionList? ")" #List} #Apply

addArgumentExpressionList
	= (@AssignmentExpression ("," @AssignmentExpression)*)

addIndex
	= "[" @Expression "]" #Index

addField
	= "." @Name #Field

addPointerField
	= "->" @Name #PointerField

addInc
	= "++" #Inc

addDec
	= "--" #Dec

PrimaryExpression
	= Constant
	/ CString
	/ "(" Expression ")"
	/ Name

LambdaExpression
	= { @LambdaParameters _ '->' _ @LambdaBody #LambdaExpression }

LambdaParameters
	= { @Name
		/ '(' _ (@addArgumentExpressionList)? _ ')'
		/ '(' _ @InferredFormalParameterList _ ')'
		 #LambdaParameters }

InferredFormalParameterList
	= { @Name ( _ ',' _ @Name)* #InferredFormalParameterList }

LambdaBody
	= { @Expression / @Block #LambdaBody }


//Literal
//=======

Constant
	= CFloat
	/ CInteger
	/ CChar

CFloat
	= { ( DECIMAL_FLOAT / HEX_FLOAT )  #Float } FLOAT_SUFFIX? _

DECIMAL_FLOAT
	= FRACTION EXPONENT?
	/ DIGIT+ EXPONENT

FRACTION
	= DIGIT* '.' DIGIT+
	/ DIGIT+ '.'

EXPONENT
	= [eE] [+\-]? DIGIT+

HEX_FLOAT
	= HEX_PREFIX HEX_FRACTION BINARY_EXPONENT?
	/ HEX_PREFIX HEX+ BINARY_EXPONENT

HEX_PREFIX
	= '0' [xX]

HEX_FRACTION
	= HEX* '.' HEX+
	/ HEX+ '.'

BINARY_EXPONENT
	= [pP] [+\-]? DIGIT+

FLOAT_SUFFIX
	= [fFdD]

CInteger
	= { ( DECIMAL / HEXICAL / OCTAL ) #Integer } INT_SUFFIX? _

DECIMAL
	= [1-9] DIGIT*

HEXICAL
	= HEX_PREFIX HEX+

OCTAL
	= '0' [0-7]*

INT_SUFFIX
	= [uU] LONG_SUFFIX?
	/ LONG_SUFFIX [uU]?

LONG_SUFFIX
	= 'll'
	/ 'LL'
	/ [lL]

CString
	=  'L'? ('"' { STRING_CONTENT* #String } '"' _)+

CChar
	= 'L'? "'" { CHAR_CONTENT* #Character } "'" _

STRING_CONTENT
	= ESCAPE
	/ ![\"\n\\] .


CHAR_CONTENT
	= ESCAPE
	/ !['\n\\] .

ESCAPE
	= SIMPLE_ESCAPE
	/ OCTAL_ESCAPE
	/ HEX_ESCAPE
	/ UCHAR

SIMPLE_ESCAPE
	= '\\' ['\"?\\abfnrtv]
	
OCTAL_ESCAPE
	= '\\' [0-7] [0-7]? [0-7]?
	
HEX_ESCAPE
	= '\\x' HEX+
