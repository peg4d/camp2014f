// PEG4d JavaScript Grammar

// # Rule naming rule:
// 1. The rule creating a object is named in UpperCamelCase
//    ex) TheRule = { @OtherRule #TheTag }
// 2. The rule not creating any object but contains # or @ is named in lowerCamelCase
//    ex) theRule = '=' @OtherRule
//    ex) theRule = DIGIT+ #Number
// 3. Otherwise, it named in UPPER_CASE
//    ex) DIGIT = [1-9][0-9]* / '0'
//
// # Tag naming rule
// 1. Tags should be named in UpperCamelCase


File
    = SourceElement*

Chunk
    = SourceElement*

WS
    = [\t\v\f \u000B\u000C\u00A0\uFEFF]
//  / "\u00A0"
//  / "\uFEFF"
//  / Zs

// Space including line terminator
__
    = (WS / LINE_TERMINATOR_SEQUENCE / COMMENT)*

// Space without line terminator
_
    = (WS / MULTI_LINE_COMMENT_SINGLE_LINE)*

LINE_TERMINATOR
    = [\n\r]

LINE_TERMINATOR_SEQUENCE
    = '\n' / '\r\n' / '\r'

COMMENT
    = MULTI_LINE_COMMENT / SINGLE_LINE_COMMENT

MULTI_LINE_COMMENT
    = '/*' (!'*/' .)* '*/'

MULTI_LINE_COMMENT_SINGLE_LINE
    = '/*' (!('*/' / LINE_TERMINATOR) .)* '*/'

SINGLE_LINE_COMMENT
    = '//' (!LINE_TERMINATOR .)*

Identifier
    = !KEYWORD IdentifierName

IdentifierName
    = { IDENTIFIER_START IDENTIFIER_PART* #Name }

IDENTIFIER_START
    = [a-zA-Z]
    / UCHAR
    / DIGIT
    / "$"
    / "_"

IDENTIFIER_PART
    = IDENTIFIER_START
//    / UnicodeCombiningMark
    / DIGIT
//    / UnicodeConnectorPunctuation
//    / "\u200C"
//    / "\u200D"

W
  = [a-zA-Z0-9_]
  / UCHAR

UCHAR
  = '\\u' HEX4
  / '\\U' HEX4 HEX4

HEX4
  = HEX HEX HEX HEX

//DIGIT
//  = [0-9]

//Automatic Semicolon Insertion

EOS
    = __ ';'
    / _ SINGLE_LINE_COMMENT? LINE_TERMINATOR_SEQUENCE
    / _ &'}'
    / __ EOF

EOF
    = !.

//Operator
//==========

"++"  = '++' __
"--"  = '--' __
"&"   = '&' !'&' __
"*"   = '*' !'=' __
"+"   = '+' ![+=] __
"-"   = '-' !('-' / [=>]) __
"~"   = '~' __
"!"   = '!' !'=' __
"{"   = '{' __
"["   = '[' __
"]"   = ']' __
"("    = '(' __
")"    = ')' __
"."    = '.' __
","    = __ ',' __
":"    = __ ':' ![>] __
"/"    = '/' !'=' __
"%"    = '%' ![=>] __
"<<"  = '<<' !'=' __
">>"  = '>>' !'=' __
"<="  = '<=' __
">="  = '>=' __
"<"    = '<' ![=] __
">"    = '>' ![=] __
"=="  = '==' ![=]__
"===" = '===' __
"!="  = '!=' ![=] __
"!==" = '!==' __
"^"    = '^' ![=] __
"|"    = '|' ![=] __
"&&"  = '&&' __
"||"  = '||' __
"?"    = '?' __
"*="  = '*=' __
"/="  = '/=' __
"%="  = '%=' __
"+="  = '+=' __
"-="  = '-=' __
"<<=" = '<<=' __
">>=" = '>>=' __
"&="  = '&=' __
"^="  = '^=' __
"|="  = '|=' __
"="    = '=' ![=] __
"break" = 'break' !W __
"case" = 'case' !W __
"catch" = 'catch' !W __
"continue" = 'continue' !W __
"debugger" = 'debugger' !W __
"default" = 'default' !W __
"delete" = 'delete' !W __
"do" = 'do' !W __
"else" = 'else' !W __
"finally" = 'finally' !W __
"for" = 'for' !W __
"function" = 'function' !W __
"if" = 'if' !W __
"in" = 'in' !W __
"instanceof" = 'instanceof' !W __
"new" = 'new' !W __
"return" = 'return' !W __
"switch" = 'switch' !W __
"this" = 'this' !W __
"throw" = 'throw' !W __
"try" = 'try' !W __
"typeof" = 'typeof' !W __
"var" = 'var' !W __
"void" = 'void' !W __
"while" = 'while' !W __
"with" = 'with' !W __
"class" = 'class' !W __
"enum" = 'enum' !W __
"export" = 'export' !W __
"extends" = 'extends' !W __
"import" = 'import' !W __
"super" = 'super' !W __
"implements" = 'implements' !W __
"interface" = 'interface' !W __
"let" = 'let' !W __
"package" = 'package' !W __
"private" = 'private' !W __
"protected" = 'protected' !W __
"public" = 'public' !W __
"static" = 'static' !W __
"yield" = 'yield' !W __
"get" = 'get' !W __
"set" = 'set' !W __
"null" = 'null' !W __
"true" = 'true' !W __
"false" = 'false' !W __

KEYWORD
    = "break" / "case" / "catch" / "continue" / "debugger" / "default" / "delete" / "do"
    / "else" / "finally" / "for" / "function" / "if" / "in" / "instanceof" / "new"
    / "return" / "switch" / "this" / "throw" / "try" / "typeof" / "var" / "void"
    / "while" / "with" / "class" / "enum" / "export" / "extends" / "import" / "super"
    / "implements" / "interface" / "let" / "package" / "private" / "protected" / "public"
    / "static" / "yield" / "null" / "true" / "false"

//Expression
//==========

ThisExpression
    = { "this" #This }

PrimaryExpression
    = ThisExpression __
    / Literal __
    / Identifier __
    / ArrayLiteral __
    / ObjectLiteral __
    / "(" Expression ")"

ArrayLiteral
    [example:[]]
    [example:[,,,]]
    [example:[1,2,3]]
    [example:[1,2,3,]]
    [example:[,1,2,3,]]
    = {( "[" (addElisionList __)? "]"  
       / "[" addElementList __ "]"
       / "[" addElementList addArrayDelimitor "]" ) #ArrayExpression }

addArrayDelimitor
    = __ ',' __ (addElisionList __)?

addElementList
    = (addElisionList __)? @AssignmentExpression ( addArrayDelimitor @AssignmentExpression )*

addElisionList
    = @ElisionExpression (__ @ElisionExpression)*

ElisionExpression
    = ',' { #Undefined }

ObjectLiteral
    [example:{}]
    [example:{ a: 1, b: 2}]
    = "{" "}" { #ObjectExpression }
    / { (  "{" addPropertyList __ "}" / "{" addPropertyList "," "}" ) #ObjectExpression }

addPropertyList
    = @PropertyAssignment ("," @PropertyAssignment)*

PropertyAssignment
    = { @PropertyName ":" @AssignmentExpression #Property }
    / { "get" @PropertyName __ "(" ")" @Block #Getter }
    / { "set" @PropertyName __ "(" @Identifier __ ")" @Block #Setter }

PropertyName
    = IdentifierName
    / StringLiteral
    / NumericLiteral

NewExpressionWithArgs
    [example: new Klass()]
    [example: new Klass(1)]
    = { "new" @MemberExpression __ @Arguments #NewExpression }

ReceiverExpression
    [example: new Klass()]
    = PrimaryExpression / FunctionExpression / NewExpressionWithArgs

MemberExpression
    [example:a.b.c.d]
    [example:a.b[0].c]
    [example:a.b[0][0]]
    = ReceiverExpression {@ __ addMemberOperator }*

addMemberOperator
    = "[" @Expression __ "]" #MemberExpression
    / "." @IdentifierName #MemberExpression

NewExpression
    [example: new Klass]
    = MemberExpression / { "new" @NewExpression #NewExpression }

CallExpression
    [example:func()]
    [example:func(1)]
    [example:func(1,2,3)]
    [example:func(1,2,3).a]
    [example:func(1,2,3)[0]]
    [example:func(1,2,3).a.b.c(2)[1].s]
    = MemberExpression {@ __ addCallOrMemberOperator }*

addCallOrMemberOperator
    = @Arguments #Apply
    / "[" @Expression __ "]" #MemberExpression
    / "." @IdentifierName #MemberExpression

Arguments
    = { "(" (addArgumentList __)? ")" #List }

addArgumentList
    = @AssignmentExpression ("," @AssignmentExpression)*

LeftHandSideExpression
    = CallExpression
    / NewExpression
 
PostfixExpression
    = { @LeftHandSideExpression _ addPostfixOperator }
    / LeftHandSideExpression

addPostfixOperator
    = "++" #Inc / "--" #Dec

UnaryExpression
    [example: ++i]
    = PostfixExpression / { addUnaryOperator @UnaryExpression }

addUnaryOperator
    = "delete" #Delete
    / "void"   #Void
    / "typeof" #TypeOf
    / "++"     #PrefixInc
    / "--"     #PrefixDec
    / "+"      #Plus
    / "-"      #Minus
    / "~"      #Compl
    / "!"      #Not

MultiplicativeExpression
    = UnaryExpression {@ ( "*" #Mul / "/" #Div / "%" #Mod ) @UnaryExpression }*

AdditiveExpression
    = MultiplicativeExpression {@ ( "+" #Add / "-" #Sub ) @MultiplicativeExpression }*
  
ShiftExpression
    = AdditiveExpression {@ ( "<<" #LeftShift / ">>" #RightShift ) @AdditiveExpression }*
  
RelationalExpression
    = ShiftExpression {@ addRelationalOperator @ShiftExpression }*

addRelationalOperator
    = "<=" #LessThanEquals
    / ">=" #GreaterThanEquals
    / "<" #LessThan
    / ">" #GreaterThan
    / "instanceof" #InstanceOf
    / <if InOperator> "in" #In
  
EqualityExpression
    = RelationalExpression {@ addEqualityOperator @RelationalExpression }*

addEqualityOperator
    = "=="  #Equals
    / "!="  #NotEquals
    / "===" #StrictEquals
    / "!==" #StrictNotEquals

BitwiseANDExpression
    = EqualityExpression {@ "&" @EqualityExpression #BitwiseAnd }*

BitwiseXORExpression
    = BitwiseANDExpression {@ "^" @BitwiseANDExpression #BitwiseXor }*

BitwiseORExpression
    = BitwiseXORExpression {@ "|" @BitwiseXORExpression #BitwiseOr }*

LogicalANDExpression
    = BitwiseORExpression {@ "&&" @BitwiseORExpression #And }*

LogicalORExpression
    = LogicalANDExpression {@ "||" @LogicalANDExpression #Or }*
  
ConditionalExpression
    = LogicalORExpression {@ "?"  @Expression ":" @LogicalORExpression #Trinary }*

AssignmentExpression
    = { @LeftHandSideExpression addAssignmentOperator @AssignmentExpression }
    / ConditionalExpression

addAssignmentOperator
    = "="   #Assign
    / "*="  #AssignMul
    / "/="  #AssignDiv
    / "%="  #AssignMod
    / "+="  #AssignAdd
    / "-="  #AssignSub
    / "<<=" #AssignLeftShift
    / ">>=" #AssignRightShift
    / "&="  #AssignBitwiseAnd
    / "^="  #AssignBitwiseXOr 
    / "|="  #AssignBitwiseOr

CommaExpression
    = AssignmentExpression {@ "," @AssignmentExpression #CommaExpression }*

Expression
    = CommaExpression

//Statement
//==========

Statement
    = Block
    / VariableStatement
    / EmptyStatement
    / ExpressionStatement
    / IfStatement
    / DoWhileStatement
    / WhileStatement
    / ForStatement
    / ForEachStatement
    / ContinueStatement
    / BreakStatement
    / ReturnStatement
    / WithStatement
    / LabelledStatement
    / SwitchStatement
    / ThrowStatement
    / TryStatement
    / DebuggerStatement

Block
    [example:{}]
    [example:{;}]
    = { "{" (@Statement __)* "}" #Block }

VariableStatement
    [example: var a = 0, b, c = 1 + 3;]
    = "var" VariableDeclarationList EOS

VariableDeclarationList
    = { @VariableDeclaration ("," @VariableDeclaration)* #VarDeclList }

VariableDeclaration
    = { @Identifier (__ addInitialiser)? #VarDecl }

addInitialiser
    = "=" @AssignmentExpression

EmptyStatement
    = { ";" #Empty }

ExpressionStatement
    = !("{" / "function") Expression EOS

IfStatement
    [example:if(1 + 1){var a = 0;}]
    = { "if" "(" @Expression ")" @Statement ("else" @Statement)? EOS #If }

DoWhileStatement
    [example:do{var a = 0;}while(2 > 1)]
    = { "do" @Statement "while" "(" @Expression ")" EOS #DoWhile }

WhileStatement
    [example:while(1){var a = 0;}]
    = { "while" "(" @Expression ")" @Statement EOS #While }

ForStatement
    [example:for(;;);]
    [example:for(i=0;i<5;);]
    [example:for(;i<5;);]
    [example:for(i=0;i<5;i++);]
    [example:for(var i=0;i<5;i++);]
    = { "for" "(" addForStatementPart ")" @[3]Statement EOS #For }

addForStatementPart
//    = <without InOperator "var" @VariableDeclarationList> ";" (@Expression)? ";" (@Expression)?
//    / (<without InOperator @Expression>)? ";" (@Expression)? ";" (@Expression)?
    = "var" @[0]VariableDeclarationList ";" (@[1]Expression)? ";" (@[2]Expression)?
    / (@[0]Expression)? ";" (@[1]Expression)? ";" (@[2]Expression)?

ForEachStatement
    [example:for(k in array);]
//    [example:for(var k in array){ i += 1;}]
//    = { "for" "(" <without InOperator ("var" @VariableDeclarationList / @LeftHandSideExpression)> "in" @Expression ")" @Statement EOS #ForEach }
    = { "for" "(" ("var" @VariableDeclarationList / @LeftHandSideExpression) "in" @Expression ")" @Statement EOS #ForEach }

ContinueStatement
    [example: continue;]
    [example: continue label;]
    = { "continue" (_ @Identifier)? EOS #Continue }

BreakStatement
    [example: break;]
    [example: break label;]
    = { "break" (_ @Identifier)? EOS #Break }

ReturnStatement
    [example: return;]
    [example: return 1;]
    = { "return" (@Expression)? EOS #Return }

WithStatement
    [example: with(a){ a.f(); }]
    = { "with" "(" @Expression ")" @Statement EOS #With }

SwitchStatement
    = { "switch" "(" @Expression ")" @CaseBlock EOS #Switch }

CaseBlock
    = { "{" (addCaseClauses)? __ "}" #CaseBlock }

addCaseClauses
    = @CaseClause (__ @CaseClause)*

CaseClause
    [example: case 2: break;]
    [example: default: break;]
    = { "case" @Expression ":" (__ (@Statement __)*)? #CaseClause }
    / { "default" ":" (__ (@Statement __)*)? #CaseClause }

LabelledStatement
    [example: label: var a = 1;]
    = { @Identifier ":" @Statement #LabelledStatement }

ThrowStatement
    [example: throw new Error()]
    = { "throw" (@Expression)? EOS #Throw }

TryStatement
    [example: try{}finally{}]
    [example: try{}catch(e){}]
    [example: try{}catch(e){}finally{}]
    = { (  "try" @[0]Block __ @[1]Catch __ @[2]Finally
         / "try" @[0]Block __ @[1]Catch
         / "try" @[0]Block __ @[2]Finally ) #TryStatement }

Catch
    [example: catch(e){}]
    = { "catch" "(" @Identifier __ ")" @Block #Catch }

Finally
    [example: finally{}]
    = { "finally" @Block #Finally }

DebuggerStatement
    = "debugger" EOS { #Debugger }

//Program
//==========

FunctionDeclaration
    = { "function" @[0]Identifier __ "(" @[1]FormalParameterList ")" "{" @[2]FunctionBody __ "}" #Function }

FunctionExpression
    = { "function" (@[0]Identifier __)? "(" @[1]FormalParameterList ")" "{" @[2]FunctionBody __ "}" #Function }

FormalParameterList
    = { (@Identifier ("," @Identifier)* __)? #List }

FunctionBody
    = { addSourceElements #Block }

addSourceElements
    = @SourceElement (__ @SourceElement)*

SourceElement
    = Statement
    / FunctionDeclaration

//Literal
//==========
Literal
    = NullLiteral / BooleanLiteral / NumericLiteral / StringLiteral / RegularExpressionLiteral

NullLiteral
    [example: null]
    = { "null" #Null }

BooleanLiteral
    [example: true]
    = { ( "true" / "false" ) #Bool }

NumericLiteral
    = OctaIntegerLiteral / HexIntegerLiteral / FloatingPointLiteral / DecimalLiteral

DecimalLiteral
    [example: 123]
    [example: +123]
    [example: -123]
    = { SIGN? [1-9] DIGIT* #DecimalInteger }

OctaIntegerLiteral
    [example: 0]
    [example: 012]
    = { SIGN? '0' ( [1-7] OCT* )? !. #OctaInteger }

HexIntegerLiteral
    [example: 0xa12]
    [example: -0Xa12]
    = { SIGN? '0' [xX] [1-9A-Fa-f] HEX* #HexInteger }

FloatingPointLiteral
    [example: 12.456]
    [example: -0.12]
    = { SIGN? ( '0' / [1-9] DIGIT* ) '.' [0-9]+ ( [eE] SIGN? [1-9] DIGIT* )? #FloatingPointNumber }

//DIGIT
//    = [0-9]

OCT
    = [0-7]

//HEX
//    = [0-9a-fA-F]

SIGN
    = ( '+' / '-' )

SOURCE
    = .

StringLiteral
    = '"' { DOUBLE_STRING_CHARACTER* #String } '"'
    / "'" { SINGLE_STRING_CHARACTER* #String } "'"

DOUBLE_STRING_CHARACTER
    = !( '"' / '\\' / LINE_TERMINATOR ) SOURCE / '\\' ESCAPE_SEQUENCE

SINGLE_STRING_CHARACTER
    = !( "'" / '\\' / LINE_TERMINATOR ) SOURCE / '\\' ESCAPE_SEQUENCE

LINE_CONTINUATION
    = '\\' LINE_TERMINATOR_SEQUENCE

ESCAPE_SEQUENCE
    = '\\' / "'" / '"' / [bfnrtv] / OCTA_ESCAPE_SEQUENCE / HEX_ESCAPE_SEQUENCE / UNICODE_ESCAPE_SEQUUENCE / LINE_TERMINATOR_SEQUENCE

OCTA_ESCAPE_SEQUENCE
    = OCT OCT OCT

HEX_ESCAPE_SEQUENCE
    = [xX] HEX HEX

UNICODE_ESCAPE_SEQUUENCE
    = [uU] HEX4

RegularExpressionLiteral
    = { '/' REGEX_BODY '/' REGEX_FLAGS #RegularExp }

REGEX_BODY
    = REGEX_FIRST_CHAR REGEX_CHAR*

REGEX_FIRST_CHAR
    = ![*\\/\x5b] REGEX_NON_TERMINATOR / REGEX_BACKSLASH_SEQUENCE / REGEX_CLASS

REGEX_CHAR
    = ![*\\/\x5b] REGEX_NON_TERMINATOR / REGEX_BACKSLASH_SEQUENCE / REGEX_CLASS

REGEX_BACKSLASH_SEQUENCE
    = '\\' REGEX_NON_TERMINATOR

REGEX_NON_TERMINATOR
    = !LINE_TERMINATOR SOURCE

REGEX_CLASS
    = '[' REGEX_CLASS_CHAR* ']'

REGEX_CLASS_CHAR
    = ![\x5d\\] REGEX_NON_TERMINATOR / REGEX_BACKSLASH_SEQUENCE

REGEX_FLAGS
    = [igms]*
