// PEG4d JavaScript Grammar

// # Rule naming rule:
// 1. The rule creating a object is named in UpperCamelCase
//    ex) TheRule = { @OtherRule #TheTag }
// 2. The rule not creating any object but contains # or @ is named in lowerCamelCase
//    ex) theRule = '=' @OtherRule
//    ex) theRule = DIGIT+ #Number
// 3. Otherwise, it named in UPPER_CASE
//    ex) DIGIT = [1-9][0-9]* / '0'
//
// # Tag naming rule
// 1. Tags should be named in UpperCamelCase


File
    = { (__ @SourceElement)* __ #Source }

Chunk
    = { (__ @SourceElement)* __ #Source }

SPACE
    = [\t\v\f \u00A0\uFEFF]
//  / Zs

// Space including line terminator
__
    [example: /* comment*/]
    [example: //comment
]
    = (SPACE / LINE_TERMINATOR_SEQUENCE / COMMENT)*

// Space without line terminator
_
    = (SPACE / MULTI_LINE_COMMENT_SINGLE_LINE)*

LINE_TERMINATOR
    = [\n\r\u2028\u2029]

LINE_TERMINATOR_SEQUENCE
    = '\n' / '\r\n' / '\r'

COMMENT
    = MULTI_LINE_COMMENT / SINGLE_LINE_COMMENT

MULTI_LINE_COMMENT
    = '/*' (!'*/' .)* '*/'

MULTI_LINE_COMMENT_SINGLE_LINE
    = '/*' (!('*/' / LINE_TERMINATOR) .)* '*/'

SINGLE_LINE_COMMENT
    = '//' (!LINE_TERMINATOR .)*

Identifier
    = !KEYWORD IdentifierName

IdentifierName
    = { IDENTIFIER_START IDENTIFIER_PART* #Name }

IDENTIFIER_START
    = [a-zA-Z$_]
    / UCHAR

IDENTIFIER_PART
    = IDENTIFIER_START
//    / UnicodeCombiningMark
    / DIGIT
//    / UnicodeConnectorPunctuation
//    / "\u200C"
//    / "\u200D"

W
  = [a-zA-Z0-9_]
  / UCHAR

UCHAR
  = '\\u' HEX4
  / '\\U' HEX4 HEX4

HEX4
  = HEX HEX HEX HEX

//DIGIT
//  = [0-9]

//Automatic Semicolon Insertion

EOS
    = __ ';'
    / _ SINGLE_LINE_COMMENT? LINE_TERMINATOR_SEQUENCE
    / _ &'}'
    / __ EOF

EOF
    = !.

//Operator
//==========

"&"   = '&' !'&'
"*"   = '*' !'='
"+"   = '+' ![+=]
"-"   = '-' !('-' / [=>])
"!"   = '!' !'='
":"    = ':' ![>]
"/"    = '/' !'='
"%"    = '%' ![=>]
"<<"  = '<<' !'='
">>"  = '>>' !'='
"<"    = '<' ![=]
">"    = '>' ![=]
"=="  = '==' ![=]
"!="  = '!=' ![=]
"^"    = '^' ![=]
"|"    = '|' ![=]
"="    = '=' ![=]
"break" = 'break' !W
"case" = 'case' !W
"catch" = 'catch' !W
"continue" = 'continue' !W
"debugger" = 'debugger' !W
"default" = 'default' !W
"delete" = 'delete' !W
"do" = 'do' !W
"else" = 'else' !W
"finally" = 'finally' !W
"for" = 'for' !W
"function" = 'function' !W
"if" = 'if' !W
"in" = 'in' !W
"instanceof" = 'instanceof' !W
"new" = 'new' !W
"return" = 'return' !W
"switch" = 'switch' !W
"this" = 'this' !W
"throw" = 'throw' !W
"try" = 'try' !W
"typeof" = 'typeof' !W
"var" = 'var' !W
"void" = 'void' !W
"while" = 'while' !W
"with" = 'with' !W
"class" = 'class' !W
"enum" = 'enum' !W
"export" = 'export' !W
"extends" = 'extends' !W
"import" = 'import' !W
"super" = 'super' !W
"implements" = 'implements' !W
"interface" = 'interface' !W
"let" = 'let' !W
"package" = 'package' !W
"private" = 'private' !W
"protected" = 'protected' !W
"public" = 'public' !W
"static" = 'static' !W
"yield" = 'yield' !W
"get" = 'get' !W
"set" = 'set' !W
"undefined" = 'undefined' !W
"null" = 'null' !W
"true" = 'true' !W
"false" = 'false' !W
"Infinity" = 'Infinity' !W
"NaN" = 'NaN' !W

KEYWORD
    = "break" / "case" / "catch" / "continue" / "debugger" / "default" / "delete" / "do"
    / "else" / "finally" / "for" / "function" / "if" / "in" / "instanceof" / "new"
    / "return" / "switch" / "this" / "throw" / "try" / "typeof" / "var" / "void"
    / "while" / "with" / "class" / "enum" / "export" / "extends" / "import" / "super"
    / "implements" / "interface" / "let" / "package" / "private" / "protected" / "public"
    / "static" / "yield" / "undefined" / "null" / "true" / "false" / "Infinity" / "NaN"

//Expression
//==========

ThisExpression
    = { "this" #This }

UndefinedExpression
    = { "undefined" #Undefined }

PrimaryExpression
    = ThisExpression
    / UndefinedExpression
    / Identifier
    / Literal
    / ArrayLiteral
    / ObjectLiteral
    / "(" __ <with InOperator1 (<with InOperator2 (<with InOperator3 (Expression)>)>)> __ ')'

ArrayLiteral
    [example:[]]
    [example:[,,,]]
    [example:[1,2,3]]
    [example:[1,2,3,]]
    [example:[,1,2,3,]]
    [example:[, 1 , 2 , 3 ,]]
    = {( "[" __ (addElisionList __)? ']'  
       / "[" __ addElementList __ ']'
       / "[" __ addElementList addArrayDelimitor __ ']' ) #Array }

addArrayDelimitor
    = __ ',' __ (addElisionList __)?

addElementList
    = (addElisionList __)? @AssignmentExpression ( addArrayDelimitor @AssignmentExpression )*

addElisionList
    = @ElisionExpression (__ @ElisionExpression)*

ElisionExpression
    = ',' { #Undefined }

ObjectLiteral
    [example:{}]
    [example:{ a: 1, b: 2}]
    = "{" __ '}' { #Object }
    / { "{" __ addPropertyList __ ("," __)? '}' #Object }

addPropertyList
    = @PropertyAssignment (__ "," __ @PropertyAssignment)*

PropertyAssignment
    = { @PropertyName __ ":" __ @AssignmentExpression #Property }
    / { "get" __ @PropertyName __ "(" __ ")" __ "{" __ @FunctionBody __ '}' #Getter }
    / { "set" __ @PropertyName __ "(" @Identifier __ ")" __ "{" __ @FunctionBody __ '}' #Setter }

PropertyName
    = IdentifierName
    / StringLiteral
    / NumericLiteral

NewExpressionWithArgs
    [example: new Klass()]
    [example: new Klass(1)]
    = { "new" __ @MemberExpression __ @Arguments #New }

ReceiverExpression
    [example: new Klass()]
    = PrimaryExpression / FunctionExpression / NewExpressionWithArgs

MemberExpression
    [example:a.b.c.d]
    [example:a.b[0]]
    [example:a.b[0][0]]
    = ReceiverExpression {@ __ addMemberOperator }*

addMemberOperator
    = "[" __ @Expression __ ']' #Index
    / "." __ @IdentifierName #Field

NewExpression
    [example: new Klass]
    = MemberExpression / { "new" __ @NewExpression #New }

CallExpression
    [example:func()]
    [example:func(1)]
    [example:func(1,2,3)]
    [example:func(1,2,3).a]
    [example:func(1,2,3)[0]]
    [example:func(1,2,3).a.b.c(2)[1].s]
    = MemberExpression {@ __ addCallOrMemberOperator }*

addCallOrMemberOperator
    = @Arguments #Apply
    / "[" __ @Expression __ ']' #Index
    / "." __ @IdentifierName #Field

Arguments
    = { "(" __ (addArgumentList __)? ')' #List }

addArgumentList
    = @AssignmentExpression (__ "," __ @AssignmentExpression)*

LeftHandSideExpression
    = CallExpression
    / NewExpression
 
PostfixExpression
    = { @LeftHandSideExpression _ addPostfixOperator }
    / LeftHandSideExpression

addPostfixOperator
    = "++" #Inc / "--" #Dec

UnaryExpression
    [example: ++i]
    = PostfixExpression / { addUnaryOperator _ @UnaryExpression }

addUnaryOperator
    = "delete" #Delete
    / "void"   #Void
    / "typeof" #TypeOf
    / "++"     #PrefixInc
    / "--"     #PrefixDec
    / "+"      #Plus
    / "-"      #Minus
    / "~"      #Compl
    / "!"      #Not

MultiplicativeExpression
    = UnaryExpression {@ __ ( "*" #Mul / "/" #Div / "%" #Mod ) __ @UnaryExpression }*

AdditiveExpression
    = MultiplicativeExpression {@ __ ( "+" #Add / "-" #Sub ) __ @MultiplicativeExpression }*
  
ShiftExpression
    = AdditiveExpression {@ __ ( "<<" #LeftShift / ">>" #RightShift ) __ @AdditiveExpression }*
  
RelationalExpression
    = ShiftExpression {@ __ addRelationalOperator __ @ShiftExpression }*

addRelationalOperator
    = "<=" #LessThanEquals
    / ">=" #GreaterThanEquals
    / "<" #LessThan
    / ">" #GreaterThan
    / "instanceof" #InstanceOf
    / (<if InOperator1> / <if InOperator2> / <if InOperator3>) "in" #In
  
EqualityExpression
    = RelationalExpression {@ __ addEqualityOperator __ @RelationalExpression }*

addEqualityOperator
    = "=="  #Equals
    / "!="  #NotEquals
    / "===" #StrictEquals
    / "!==" #StrictNotEquals

BitwiseANDExpression
    = EqualityExpression {@ __ "&" __ @EqualityExpression #BitwiseAnd }*

BitwiseXORExpression
    = BitwiseANDExpression {@ __ "^" __ @BitwiseANDExpression #BitwiseXor }*

BitwiseORExpression
    = BitwiseXORExpression {@ __ "|" __ @BitwiseXORExpression #BitwiseOr }*

LogicalANDExpression
    = BitwiseORExpression {@ __ "&&" __ @BitwiseORExpression #And }*

LogicalORExpression
    = LogicalANDExpression {@ __ "||" __ @LogicalANDExpression #Or }*
  
ConditionalExpression
    = LogicalORExpression {@ __ "?" __ @AssignmentExpression __ ":" __ @AssignmentExpression #Trinary }*

AssignmentExpression
    = { @LeftHandSideExpression __ addAssignmentOperator __ @AssignmentExpression }
    / ConditionalExpression

addAssignmentOperator
    = "="   #Assign
    / "*="  #AssignMul
    / "/="  #AssignDiv
    / "%="  #AssignMod
    / "+="  #AssignAdd
    / "-="  #AssignSub
    / "<<=" #AssignLeftShift
    / ">>=" #AssignRightShift
    / "&="  #AssignBitwiseAnd
    / "^="  #AssignBitwiseXOr 
    / "|="  #AssignBitwiseOr

Expression
    = AssignmentExpression {@ __ "," __ @AssignmentExpression #Expression }*

//Statement
//==========

Statement
    = Block
    / VariableStatement
    / EmptyStatement
    / ExpressionStatement
    / IfStatement
    / DoWhileStatement
    / WhileStatement
    / ForStatement
    / ForEachStatement
    / ContinueStatement
    / BreakStatement
    / ReturnStatement
    / WithStatement
    / LabelledStatement
    / SwitchStatement
    / ThrowStatement
    / TryStatement
    / DebuggerStatement

Block
    [example:{}]
    [example:{;}]
    = { "{" __ (@Statement __)* '}' #Block }

VariableStatement
    [example: var a = 0, b, c = 1 + 3;]
    = "var" __ VariableDeclarationList EOS

VariableDeclarationList
    = { @VariableDeclaration (__ "," __ @VariableDeclaration)* #VarDeclList }

VariableDeclaration
    = { @Identifier (__ addInitialiser)? #VarDecl }

addInitialiser
    = "=" __ @AssignmentExpression

EmptyStatement
    = { ';' #Empty }

ExpressionStatement
    [example: (function(){})();]
    = !('{' / 'function') Expression EOS

IfStatement
    [example:if(1 + 1){;}]
    = { "if" __ "(" __ @Expression __ ")" __ @Statement (__ "else" __ @Statement)? #If }

DoWhileStatement
    [example:do{;}while(2 > 1)]
    = { "do" __ @Statement __ "while" __ "(" __ @Expression __ ')' EOS #DoWhile }

WhileStatement
    [example:while(1){;}]
    = { "while" __ "(" __ @Expression __ ")" __ @Statement #While }

ForStatement
    [example:for(;;);]
    [example:for(i=0;i<5;);]
    [example:for(;i<5;);]
    [example:for(i=0;i<5;i++);]
    [example:for(var i=0;i<5;i++);]
    = { "for" __ "(" __ addForStatementPart __ ")" __ @[3]Statement #For }

addForStatementPart
    = "var" __ <without InOperator1 @[0]VariableDeclarationList > __ ";" __ (@[1]Expression)? __ ";" __ (@[2]Expression)?
    / <without InOperator2 @[0]Expression >? __ ";" __ (@[1]Expression)? __ ";" __ (@[2]Expression)?

ForEachStatement
    [example:for(k in array);]
    [example:for(var k in array){ i += 1;}]
    = { "for" __ "(" __ <without InOperator3 "var" __ @VariableDeclarationList / @LeftHandSideExpression > __ "in" __ @Expression __ ")" __ @Statement #ForEach }

ContinueStatement
    [example: continue;]
    [example: continue label;]
    = { "continue" (_ @Identifier)? EOS #Continue }

BreakStatement
    [example: break;]
    [example: break label;]
    = { "break" (_ @Identifier)? EOS #Break }

ReturnStatement
    [example: return;]
    [example: return 1;]
    = { "return" (_ @Expression)? EOS #Return }

WithStatement
    [example: with(a){ a.f(); }]
    = { "with" __ "(" __ @Expression __ ")" @Statement #With }

SwitchStatement
    [example: switch(n){ case 0: break; case 1: return 0; default: throw 0; }]
    = { "switch" __ "(" __ @Expression __ ")" @CaseBlock #Switch }

CaseBlock
    = { "{" __ addCaseClauses? __ '}' #CaseBlock }

addCaseClauses
    = @CaseClause (__ @CaseClause)*

CaseClause
    [example: case 2: break;]
    [example: default: break;]
    = { "case" __ @Expression __ ":" __ (@Statement __)* #CaseClause }
    / { "default" __ ":" __ (@Statement __)* #CaseClause }

LabelledStatement
    [example: label: var a = 1;]
    = { @Identifier __ ":" __ @Statement #Label }

ThrowStatement
    [example: throw new Error()]
    = { "throw" _ @Expression EOS #Throw }

TryStatement
    [example: try{}finally{}]
    [example: try{}catch(e){}]
    [example: try{}catch(e){}finally{}]
    = { (  "try" __ @[0]Block __ @[1]Catch __ @[2]Finally
         / "try" __ @[0]Block __ @[1]Catch
         / "try" __ @[0]Block __ @[2]Finally ) #Try }

Catch
    [example: catch(e){}]
    = { "catch" __ "(" __ @Identifier __ ")" __ @Block #Catch }

Finally
    [example: finally{}]
    = { "finally" __ @Block #Finally }

DebuggerStatement
    = "debugger" EOS { #Debugger }

//Program
//==========

FunctionDeclaration
    [example: function func(){}]
    [example: function func(n){ return n+1; }]
    = { "function" __ @[0]Identifier __ "(" __ @[1]FormalParameterList __ ")" __ "{" __ @[2]FunctionBody __ '}' #Function }

FunctionExpression
    [example: function func(){}]
    [example: function (){}]
    = { "function" __ (@[0]Identifier __)? "(" __ @[1]FormalParameterList __ ")" __ "{" __ @[2]FunctionBody __ '}' #Function }

FormalParameterList
    = { ( @Identifier (__ "," __ @Identifier)* )? #List }

FunctionBody
    = { addSourceElements? #Block }

addSourceElements
    = @SourceElement (__ @SourceElement)*

SourceElement
    = FunctionDeclaration
    / Statement

//Literal
//==========
Literal
    = NullLiteral / BooleanLiteral / NumericLiteral / StringLiteral / RegularExpressionLiteral

NullLiteral
    [example: null]
    = { "null" #Null }

BooleanLiteral
    [example: true]
    = { ( "true" / "false" ) #Bool }

NumericLiteral
    [example: 0x1F]
    [example: 0123]
    [example: 0.12]
    [example: 1234]
    = HexIntegerLiteral / FloatingPointLiteral / OctaIntegerLiteral / DecimalLiteral / InfinityLiteral / NaNLiteral

DecimalLiteral
    [example: 123]
    = { DECIMAL_INTEGER #DecimalInteger }

OctaIntegerLiteral
    [example: 0]
    [example: 012]
    = { '0' OCT* #OctaInteger }

HexIntegerLiteral
    [example: 0xa12]
    = { '0' [xX] [1-9A-Fa-f] HEX* #HexInteger }

FloatingPointLiteral
    [example: 12.456]
    [example: 12.456e-78]
    [example: 0.12]
    [example: .12]
    [example: .12]
    [example: .12e3]
    [example: 5e3]
    = { ( '0' / [1-9] DIGIT* )? '.' DIGIT+ EXPONENT_PART? #FloatingPointNumber }
    / { DECIMAL_INTEGER EXPONENT_PART? #FloatingPointNumber }

InfinityLiteral
    = { 'Infinity' #FloatingPointNumber }

NaNLiteral
    = { 'NaN' #FloatingPointNumber }

DECIMAL_INTEGER
    = [1-9] DIGIT*

EXPONENT_PART
    = [eE] SIGN? [1-9] DIGIT*

//DIGIT
//    = [0-9]

OCT
    = [0-7]

//HEX
//    = [0-9a-fA-F]

SIGN
    = ( '+' / '-' )

SOURCE
    = .

StringLiteral
    = '"' { DOUBLE_STRING_CHARACTER* #String } '"'
    / "'" { SINGLE_STRING_CHARACTER* #String } "'"

DOUBLE_STRING_CHARACTER
    = !( '"' / '\\' / LINE_TERMINATOR ) SOURCE / '\\' ESCAPE_SEQUENCE / LINE_CONTINUATION

SINGLE_STRING_CHARACTER
    = !( "'" / '\\' / LINE_TERMINATOR ) SOURCE / '\\' ESCAPE_SEQUENCE / LINE_CONTINUATION

LINE_CONTINUATION
    = '\\' LINE_TERMINATOR_SEQUENCE

ESCAPE_SEQUENCE
    = '\\' / "'" / '"' / [bfnrtv] / OCTA_ESCAPE_SEQUENCE / HEX_ESCAPE_SEQUENCE / UNICODE_ESCAPE_SEQUUENCE / LINE_TERMINATOR_SEQUENCE

OCTA_ESCAPE_SEQUENCE
    = OCT OCT OCT

HEX_ESCAPE_SEQUENCE
    = [xX] HEX HEX

UNICODE_ESCAPE_SEQUUENCE
    = [uU] HEX4

RegularExpressionLiteral
    [example: /.*(?=#[^\s]*$)/]
    = { '/' REGEX_BODY '/' REGEX_FLAGS #RegularExp }

REGEX_BODY
    = REGEX_FIRST_CHAR REGEX_CHAR*

REGEX_FIRST_CHAR
    = REGEX_BACKSLASH_SEQUENCE / ![*\\/\x5b] REGEX_NON_TERMINATOR / REGEX_CLASS

REGEX_CHAR
    = '*' / REGEX_FIRST_CHAR

REGEX_BACKSLASH_SEQUENCE
    = '\\' REGEX_NON_TERMINATOR

REGEX_NON_TERMINATOR
    = !LINE_TERMINATOR SOURCE

REGEX_CLASS
    = '[' REGEX_CLASS_CHAR* ']'

REGEX_CLASS_CHAR
    = ![\x5d\\] REGEX_NON_TERMINATOR / REGEX_BACKSLASH_SEQUENCE

REGEX_FLAGS
    = [gimsy]*
