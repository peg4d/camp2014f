// PEG4d JavaScript Grammar

// # Rule naming rule:
// 1. The rule creating a object is named in UpperCamelCase
//    ex) TheRule = { @OtherRule #TheTag }
// 2. The rule not creating any object but contains # or @ is named in lowerCamelCase
//    ex) theRule = '=' @OtherRule
//    ex) theRule = DIGIT+ #Number
// 3. Otherwise, it named in UPPER_CASE
//    ex) DIGIT = [1-9][0-9]* / '0'
//
// # Tag naming rule
// 1. Tags should be named in UpperCamelCase


File
	= Statement*

Chunk
	= Statement*

WS
  = [\t\v\f ]
//  / "\u00A0"
//  / "\uFEFF"
//  / Zs

// Space including line terminator
__
    = (WS / LINE_TERMINATOR_SEQUENCE / COMMENT)*

// Space without line terminator
_
    = (WS / MULTI_LINE_COMMENT_SINGLE_LINE)*

LINE_TERMINATOR
    = [\n\r]

LINE_TERMINATOR_SEQUENCE
    = '\n' / '\r\n' / '\r'

COMMENT
  = MULTI_LINE_COMMENT / SINGLE_LINE_COMMENT

MULTI_LINE_COMMENT
  = '/*' (!'*/' .)* '*/'

MULTI_LINE_COMMENT_SINGLE_LINE
  = '/*' (!('*/' / LINE_TERMINATOR) .)* '*/'

SINGLE_LINE_COMMENT
  = '//' (!LINE_TERMINATOR .)*

//Automatic Semicolon Insertion

EOS
  = __ ';'
  / _ SINGLE_LINE_COMMENT? LINE_TERMINATOR_SEQUENCE
  / _ &'}'
  / __ EOF

EOF
  = !.

//Operator
//==========

"++"  = '++' __
"--"  = '--' __
"&"   = '&' !'&' __
"*"   = '*' !'=' __
"+"   = '+' ![+=] __
"-"   = '-' !('-' / [=>]) __
"~"   = '~' __
"!"   = '!' !'=' __
"{"   = '{' __
"["   = '[' __
"]"   = ']' __
"("	  = '(' __
")"	  = ')' __
"."	  = '.' __
","	  = ',' __
":"	  = ':' ![>] __
"/"	  = '/' !'=' __
"%"	  = '%' ![=>] __
"<<"  = '<<' !'=' __
">>"  = '>>' !'=' __
"<="  = '<=' __
">="  = '>=' __
"<"	  = '<' ![=] __
">"	  = '>' ![=] __
"=="  = '==' ![=]__
"===" = '===' __
"!="  = '!=' ![=] __
"!==" = '!==' __
"^"	  = '^' ![=] __
"|"	  = '|' ![=] __
"&&"  = '&&' __
"||"  = '||' __
"?"	  = '?' __
"*="  = '*=' __
"/="  = '/=' __
"%="  = '%=' __
"+="  = '+=' __
"-="  = '-=' __
"<<=" = '<<=' __
">>=" = '>>=' __
"&="  = '&=' __
"^="  = '^=' __
"|="  = '|=' __
"="	  = '=' ![=] __
"break" = 'break' !W
"case" = 'case' !W
"catch" = 'catch' !W
"continue" = 'continue' !W
"debugger" = 'debugger' !W
"default" = 'default' !W
"delete" = 'delete' !W
"do" = 'do' !W
"else" = 'else' !W
"finally" = 'finally' !W
"for" = 'for' !W
"function" = 'function' !W
"if" = 'if' !W
"in" = 'in' !W
"instanceof" = 'instanceof' !W
"new" = 'new' !W
"return" = 'return' !W
"switch" = 'switch' !W
"this" = 'this' !W
"throw" = 'throw' !W
"try" = 'try' !W
"typeof" = 'typeof' !W
"var" = 'var' !W
"void" = 'void' !W
"while" = 'while' !W
"with" = 'with' !W
"class" = 'class' !W
"enum" = 'enum' !W
"export" = 'export' !W
"extends" = 'extends' !W
"import" = 'import' !W
"super" = 'super' !W
"implements" = 'implements' !W
"interface" = 'interface' !W
"let" = 'let' !W
"package" = 'package' !W
"private" = 'private' !W
"protected" = 'protected' !W
"public" = 'public' !W
"static" = 'static' !W
"yield" = 'yield' !W

KEYWORD
    = "break" / "case" / "catch" / "continue" / "debugger" / "default" / "delete" / "do"
    / "else" / "finally" / "for" / "function" / "if" / "in" / "instanceof" / "new"
    / "return" / "switch" / "this" / "throw" / "try" / "typeof" / "var" / "void"
    / "while" / "with" / "class" / "enum" / "export" / "extends" / "import" / "super"
    / "implements" / "interface" / "let" / "package" / "private" / "protected" / "public"
    / "static" / "yield"

//Expression
//==========

Expression
    = CommaExpression

CommaExpression
	= AssignmentExpression {@ "," @AssignmentExpression #CommaExpression }*

AssignmentExpression
	= { @UnaryExpression addAssignmentOperator @AssignmentExpression }
	/ ConditionalExpression

addAssignmentOperator
	= "="   #Assign
	/ "*="  #AssignMul
	/ "/="  #AssignDiv
	/ "%="  #AssignMod
	/ "+="  #AssignAdd
	/ "-="  #AssignSub
	/ "<<=" #AssignLeftShift
	/ ">>=" #AssignRightShift
	/ "&="  #AssignBitwiseAnd
	/ "^="  #AssignBitwiseXOr
	/ "|="  #AssignBitwiseOr

ConstantExpression
	= ConditionalExpression

ConditionalExpression
	= LogicalORExpression {@ "?"  @Expression ":" @LogicalORExpression #Trinary }*

LogicalORExpression
	= LogicalANDExpression {@ "||" @LogicalANDExpression #Or }*

LogicalANDExpression
	= InclusiveORExpression {@ "&&" @InclusiveORExpression #And }*

InclusiveORExpression
	= ExclusiveORExpression {@ "|" @ExclusiveORExpression #BitwiseOr }*

ExclusiveORExpression
	= ANDExpression {@ "^" @ANDExpression #BitwiseXor }*

ANDExpression
	= EqualityExpression {@ "&" @EqualityExpression #BitwiseAnd }*

EqualityExpression
	= RelationalExpression {@ ( "==" #Equals / "!=" #NotEquals ) @RelationalExpression }*

RelationalExpression
	= ShiftExpression {@ ( "<=" #LessThanEquals / ">=" #GreaterThanEquals / "<" #LessThan / ">" #GreaterThan ) @ShiftExpression }*

ShiftExpression
	= AdditiveExpression {@ ( "<<" #LeftShift / ">>" #RightShift ) @AdditiveExpression }*

AdditiveExpression
	= MultiplicativeExpression {@ ( "+" #Add / "-" #Sub ) @MultiplicativeExpression }*

MultiplicativeExpression
	= CastExpression {@ ( "*" #Mul / "/" #Div / "%" #Mod ) @CastExpression }*

UnaryExpression
	= PostfixExpression
	/ { "++"    @UnaryExpression #PrefixInc }
	/ { "--"    @UnaryExpression #PrefixDec }
	/ { "&"    @CastExpression #Address }
	/ { "*"   @CastExpression #Star }
	/ { "+"   @CastExpression #Plus }
	/ { "-"  @CastExpression #Minus }
	/ { "~"  @CastExpression #Compl }
	/ { "!"   @CastExpression #Not }
	/ { "sizeof"  ( @UnaryExpression / "(" @Type ")" ) #SizeOf }

CastExpression
	= { "(" @Type ")" @CastExpression #Cast }
	/ UnaryExpression

PostfixExpression
	= ( PrimaryExpression / { "(" @Type ")" "{" @{ (addInitializerList)* ","? #Initializer } "}" } )
	{@ (addFunctionCall / addIndex / addField / addInc / addDec) }*

addFunctionCall
	= @{ "(" addArgumentExpressionList? ")" #List} #Apply

addArgumentExpressionList
	= (@AssignmentExpression ("," @AssignmentExpression)*)

addIndex
	= "[" @Expression "]" #Index

addField
	= "." @Name #Field

addPointerField
	= "->" @Name #PointerField

addInc
	= "++" #Inc

addDec
	= "--" #Dec

PrimaryExpression
	= Constant
	/ CString
	/ "(" Expression ")"
	/ Name

//Statement
//==========
Block
	[example:{var a = 0;}]
	= { "{" (@Statement)* "}" #Block }

Statement
    [example:var a = 0;]
		[example:break;]
		[example:if(1 + 1){var a = 0;}]
		[example:switch(1 + 1){case 1: break;}]
		[example:while(1 + 1){var a = 0;}]
		[example:do{var a = 0;}while(1 + 1)]
		[example:for(;;){}]
    = 'var a = 0;'
		/ Block
		/ { "if" "(" @Expression ")" @Statement ("else" @Statement)? #If }
		/ { "switch" "(" @Expression ")" "{" @CaseBlock (@DefaultBlock)? "}" #Switch }
		/ { "while" "(" @Expression ")" @Statement #While }
		/ { "do" @Statement "while" "(" @Expression ")" #DoWhile }
		/ { "for" "(" (@Expression)? ";" (@Expression)? ";" (@Expression)? ")" @Statement #For }
		/ { "continue" @LabelledStatement}
		/ { "return"}
		/ { "const"}
		/ { "debugger"}
		/ { "import"}
		/ { "export"}
		/ { "function"}
		/ { "let"}
		/ { "throw"}
		/ { "try"}
		/ { "break" EOS #Break }
		/ { "var" @Name ("=" @Expression)? ("," @Name ("=" @Expression)?)* EOS}
		/ { "with"}
		/ { "yield"}

CaseBlock
	= 'case 1: break;'
	/ { "case" @ConstantExpression ":" @Statement #CaseBlock}

DefaultBlock
	= 'default: break;'
	/ { "default" ":" @Statement #DefaultBlock}

LabelledStatement
	= { "label"}

//Literal
//==========
Literal
    [example:1]
    = '1'
