// PEG4d Bash file

// Naming rule:
// 1. The rule that creating a object is named in UpperCamelCase
// 2. The rule that contains # or @ expression is named in lowerCamelCase
// 3. Otherwise, it named in UPPER_CASE


File
	[全体統合: 松村]
	= { (@Statement)* }

S
	= ([ \t\n\r] / COMMENT)

_
    = S*

COMMENT
	= '#' (!BREAK .)*

BREAK
   = '\n' / '\r\n' / '\r'

NL
	= ';' / BREAK

W
	= [a-zA-Z0-9_]

NAME
	= W+

Statement
	= IfStatement
	/ WhileStatement
	/ UntilStatement
	/ ForStatement
	/ FunctionStatement
	/ CaseStatement
	/ DeclareStatement
	/ LetStatement
	/ Command

IfStatement	//田村
	= { 'if' 'test'? @Expression NL
		'then' NL
		@Block
		('elif' @Expression NL 'then' NL @Block)*
		('else' @Expression NL @Block)?
		'fi' NL #IfStatement }

ForStatement
	= { 'for' ( @Literal 'in' @Array / '((' @Expression NL @Expression NL @Expression '))' ) NL
        'do' NL
        @Block
        'done' NL #ForStatement }

FunctionStatement
	= { ( @FunctionDecl / @FunctionCall ) #functionStatement }
	
FunctionDecl
	= { 'function'? S* @FunctionName '()' S* '{' S* @Statement  S* '}' #functionDecl }

FunctionCall
	= { @FunctionName S* ArgList S* #functionCall }

FunctionName
	= { Name #functionName }

ArgList
	= ( @Arg S+ )+

Arg
	= { W #arg }

CaseStatement
	= { 'case' _ case #CaseStatement }
	
case
	= @Variable _ 'in' _ caseMember _ (caseMember _)* (lastCaseMember / 'esac' ) _
	
caseMember
	= ( @Expression ')' _ @Statement _ (@Statement _)* ';;')
	
lastCaseMember
	= @Defualt _ ((@Statement) _) ((( 'esac' / @Statement) _)*) 
	
Defualt
    = { '*' #DefualtExpression } ')'

UntilStastement
	= { 'until' Expression NL
	   'do' NL
	   Block
	   'done' NL #Unitl}

DeclareStatement
	= { 'declare' _ ( '-i' #Num / '-a' #Array ) _ Name NL }
	/ { 'declare' _ Name NL #String }

LetStatement
	= { 'let' _ postfixExpression _ Name NL }

postfixExpression
	= '++' #PrefixInc
	/ '--' #PrefixDec

Name
	= { NAME #Name } _

WhileStatement
	= { 'while' Expression NL
	    'do' NL
	    Block
	    'done' NL #WhileStatement }

Command
	= CommandExpr _ NL	// <new line>, ';', '&'

CommandExpr
	= { @CommandList _ @Background? #command }

Background
	= { '&' #background } _

CommandList
	= OrList

OrList
	= AndList {@ _ '||' _ @AndList #or}*

AndList
	= PipedCommand {@ _ '&&' _ @PipedCommand #and}*

PipedCommand
	= SingleCommand {_ '|' _ @SingleCommand #pipe}*

SingleCommand
	= { @CmdSymbolSeq (S+ (@CommandArg / @Redirect))* #singleCommand }

Redirect
	= { @RedirectOpArgLess / @RedirectOp _ @CommandArg #redirect }

RedirectOp
	= {
		NUMBER? '>>'
		/ NUMBER? '>'
		/ '&>>'
		/ '&>'
		/ '<<<'	// here string
		/ '<'
	 #redirectOp }

RedirectOpArgLess
	= { NUMBER '>&' NUMBER #redirectOp }

NUMBER
	= '0'
	/ [1-9][0-9]*

CmdSymbolSeq
	= { @CmdSymbol+ #commandName }

CommandArg
	= { @CmdSymbol+ #commandArg }

CmdSymbol
	= SingleQuoteString
	/ DoubleQuoteString
	/ SubCmd
	/ SubExpr
	/ Identifier

SubCmd
	= '`' S? { @CommandExpr S? NL? #backquoteSubstitution } S? '`'
	/ '$(' S? { @CommandExpr S? NL? #substitution } S? ')'

SubExpr
	= '$' { @SubExprSuffix #subExpr}
	/ '${' { @VarName '[' @INDEX ']' #arraySubExpr} '}'
	/ '${' { @SubExprSuffix #subExpr} '}'

INDEX
	= NUMBER / '@'

SubExprSuffix
	= VarName
	/ { '?' / '*' / '@' / '#' /NUMBER #specialChar }

VarName
	= { '_' ('_' / LETTER / NUMBER)+ 
		/ LETTER ('_' / LETTER / NUMBER)* #varName }

LETTER
	= [a-zA-Z]+

Identifier	//TODO: utf8
	= { '$' / (ESCAPED_CHAR / !FORBIDDEN_CHAR . )+ #identifier }

FORBIDDEN_CHAR
	= '\t' / ' ' / '\n' / '\r' / '{' / '}' / '(' / ')' 
	/ '!' / '`' / '\'' / '"' / '&' / '|' / '#' / '$' / '<' / '>'

ESCAPED_CHAR
	= '\\' (FORBIDDEN_CHAR / . )


Expression
	= 内田

Literal
	= 内田

Array
	= 石井

FilePath
	[example: /dir/file]
	[example: "dir name/file"]
	[example: dir\ name/file]
	[example: /dir/$file]
	= 森谷
