// PEG4d Bash file

File
	= { (@Statement)* }

Chunk
	= Statement

S
	= ([ \t\n\r] / COMMENT)

_
    = S*

COMMENT
	= '#' (!BREAK .)*

BREAK
   = '\n' / '\r\n' / '\r'

NL
	= ';' / BREAK

W
	= [a-zA-Z0-9_]

Statement
	= IfStatement
	/ WhileStatement
	/ UntilStatement
	/ ForStatement
	/ FunctionStatement
	/ CaseStatement
	/ DeclareStatement
	/ LetStatement
	/ Command

Block
	= { (@Statement)* #Block }

IfStatement	//田村
	= { 'if' 'test'? @Expression NL
		'then' NL
		@Block
		('elif' @Expression NL 'then' NL @Block)*
		('else' @Expression NL @Block)?
		'fi' NL #IfStatement }

ForStatement
	= { 'for' ( @Literal 'in' @Array / '((' @Expression NL @Expression NL @Expression '))' ) NL
        'do' NL
        @Block
        'done' NL #ForStatement }

FunctionStatement
	= { ( @FunctionDecl / @FunctionCall ) #functionStatement }
	
FunctionDecl
	= { 'function'? S* @FunctionName '()' S* '{' S* @Statement  S* '}' #functionDecl }

FunctionCall
	= { @FunctionName S* ArgList S* #functionCall }

FunctionName
	= { Name #functionName }

ArgList
	= ( @Arg S+ )+

Arg
	= { W #arg }

CaseStatement
	= { 'case' _ case #CaseStatement }
	
case
	= @Variable _ 'in' _ @CaseMember _ (@CaseMember _)* (@LastCaseMember / 'esac' ) _
	
CaseMember
	= { @Expression ')' _ @Statement _ (@Statement _)* ';;' #CaseMember }

LastCaseMember
	= { @Defualt _ ((@Statement) _) ((( 'esac' / @Statement) _)*)  #LastCaseMember }

Defualt
    = { '*' #DefualtExpression } ')'

UntilStastement
	= { 'until' Expression NL
	   'do' NL
	   Block
	   'done' NL #Unitl}

DeclareStatement
	= { 'declare' _ ( '-i' #Num / '-a' #Array ) _ Name NL }
	/ { 'declare' _ Name NL #String }

LetStatement
	= { 'let' _ postfixExpression _ Name NL }

postfixExpression
	= '++' #PrefixInc
	/ '--' #PrefixDec

Name
	= { NAME #Name } _

WhileStatement
	= { 'while' Expression NL
	    'do' NL
	    Block
	    'done' NL #WhileStatement }

Command
	= CommandExpr _ NL	// <new line>, ';', '&'

CommandExpr
	= { @CommandList _ @Background? #command }

Background
	= { '&' #background } _

CommandList
	= OrList

OrList
	= AndList {@ _ '||' _ @AndList #or}*

AndList
	= PipedCommand {@ _ '&&' _ @PipedCommand #and}*

PipedCommand
	= SingleCommand {_ '|' _ @SingleCommand #pipe}*

SingleCommand
	= { @CmdSymbolSeq (S+ (@CommandArg / @Redirect))* #singleCommand }

Redirect
	= { @RedirectOpArgLess / @RedirectOp _ @CommandArg #redirect }

RedirectOp
	= {
		NUMBER? '>>'
		/ NUMBER? '>'
		/ '&>>'
		/ '&>'
		/ '<<<'	// here string
		/ '<'
	 #redirectOp }

RedirectOpArgLess
	= { NUMBER '>&' NUMBER #redirectOp }

NUMBER
	= '0'
	/ [1-9][0-9]*

CmdSymbolSeq
	= { @CmdSymbol+ #commandName }

CommandArg
	= { @CmdSymbol+ #commandArg }

CmdSymbol
	= SingleQuoteString
	/ DoubleQuoteString
	/ SubCmd
	/ SubExpr
	/ Identifier

SubCmd
	= '`' S? { @CommandExpr S? NL? #backquoteSubstitution } S? '`'
	/ '$(' S? { @CommandExpr S? NL? #substitution } S? ')'

SubExpr
	= '$' { @SubExprSuffix #subExpr}
	/ '${' { @VarName '[' @INDEX ']' #arraySubExpr} '}'
	/ '${' { @SubExprSuffix #subExpr} '}'

INDEX
	= NUMBER / '@'

SubExprSuffix
	= VarName
	/ { '?' / '*' / '@' / '#' /NUMBER #specialChar }

VarName
	= { '_' ('_' / LETTER / NUMBER)+ 
		/ LETTER ('_' / LETTER / NUMBER)* #varName }

LETTER
	= [a-zA-Z]+

Identifier	//TODO: utf8
	= { '$' / (ESCAPED_CHAR / !FORBIDDEN_CHAR . )+ #identifier }

FORBIDDEN_CHAR
	= '\t' / ' ' / '\n' / '\r' / '{' / '}' / '(' / ')' 
	/ '!' / '`' / '\'' / '"' / '&' / '|' / '#' / '$' / '<' / '>'

ESCAPED_CHAR
	= '\\' (FORBIDDEN_CHAR / . )

Expression
	= TestCommand
	/ ExprCommand
	/ AssignmentExpression

TestCommand
	= { 'test' S+ @EqualityExpression #Test}

ExprCommand
	= { 'expr' S+ @EqualityExpression #Test}

AssignmentExpression
	= EqualityExpression {@ '=' @AssignmentExpression S* #Assign }*

EqualityExpression
	= RelationalExpression {@ ( "-eq" #Equals / "-ne" #NotEquals) @RelationalExpression }*

RelationalExpression
	= AdditiveExpression {@ ( "-le" #LessThanEquals / "-ge" #GreaterThanEquals / "-lt" #LessThan / "-gt" #GreaterThan ) @AdditiveExpression }*

AdditiveExpression
	= MultiplicativeExpression {@ ( "+" #Add / "-" #Sub ) @MultiplicativeExpression }*

MultiplicativeExpression
	= PrimaryExpression {@ ( "*" #Mul / "/" #Div / "%" #Mod ) @PrimaryExpression }*

PrimaryExpression
	= { '$(' S* (@Expression / @Command) S* ')' #SubCommand }
	/ { '${' @Name '}' #Variable }
	/ { '$' @Name '' #Variable }
	/ { '((' @Expression '))' #Variable }
	/ { '[' S+ @Expression S+ ']' #Variable }
	/ Literal

Literal
	= CFloat
	/ CInteger
	/ Name
	/ CString

CString
	=  '"' { STRING_CONTENT* #String } '"'
	/ "'" { STRING_CONTENT* #String } "'"

STRING_CONTENT
	= ESCAPE
	/ ![\"\n\\] .

ESCAPE
	= SIMPLE_ESCAPE
	/ OCTAL_ESCAPE
	/ HEX_ESCAPE
	/ UCHAR

UCHAR
	= '\\u' HEX4
	/ '\\U' HEX4 HEX4

HEX4
	= HEX HEX HEX HEX

SIMPLE_ESCAPE
	=	 '\\' ['\"?\\abfnrtv]

OCTAL_ESCAPE
	= '\\' [0-7] [0-7]? [0-7]?

HEX_ESCAPE
	= '\\x' HEX+

Name
	= { NAME #Name } S*

KEYWORD
	= 'for' / 'while' / 'do' / 'done' / 'if' / 'case'

DIGIT
	= [0-9]

CInteger
	= { ( DECIMAL / HEXICAL / OCTAL ) #Integer } INT_SUFFIX? S*

CFloat
	= { ( DECIMAL_FLOAT / HEX_FLOAT )  #Float } FLOAT_SUFFIX? S*

DECIMAL
	= [1-9] DIGIT*

HEXICAL
	= HEX_PREFIX HEX+

OCTAL
	= '0' [0-7]*

INT_SUFFIX
	= [uU] LONG_SUFFIX?
	/ LONG_SUFFIX [uU]?

LONG_SUFFIX
	= 'll'
	/ 'LL'
	/ [lL]

DECIMAL_FLOAT
	= FRACTION EXPONENT?
	/ DIGIT+ EXPONENT

HEX_FRACTION
	= HEX* '.' HEX+
	/ HEX+ '.'

FRACTION
	= DIGIT* '.' DIGIT+
	/ DIGIT+ '.'

BINARY_EXPONENT
	= [pP] [+\-]? DIGIT+

FLOAT_SUFFIX
	= [flFL]

EXPONENT
	= [eE] [+\-]? DIGIT+

HEX_FLOAT
	= HEX_PREFIX HEX_FRACTION BINARY_EXPONENT?
	/ HEX_PREFIX HEX+ BINARY_EXPONENT

HEX_PREFIX
	= '0' [xX]

//Array
//	= 石井
//
//FilePath
//	[example: /dir/file]
//	[example: "dir name/file"]
//	[example: dir\ name/file]
//	[example: /dir/$file]
//	= 森谷
